# project.org

* Prime                                                               :prime:
** ideas
*** 多级地图, 像百度地图那样
** Thesis

#+INCLUDE: ~/Wally/GraduationProject/Thesis/README.md
#+INCLUDE: ~/Wally/GraduationProject/Thesis/ChangeLog.txt
#+INCLUDE: ~/Wally/GraduationProject/Thesis/literature.org
#+INCLUDE: ~/Wally/GraduationProject/Thesis/julie.org
#+INCLUDE: ~/Wally/GraduationProject/Thesis/thesis.tex
#+INCLUDE: ~/Wally/Project/BUAAthesis

*** buaathesis
**** BUAAthesis analysis
***** 文件后缀bst cls
+ *cls* (class): 稿件类型文件，可用命令\documentclass调用。
+ *bst*: BibTeX-style-file

***** encoding                                                 :encoding:

多人合作的时候涉及多平台，因而统一编码非常重要。
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
% !mode:: "tex:utf-8"
...
\end{minted}
#+end_latex

***** 模板声明
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \NeedsTeXFormat{LaTeX2e}[2007/10/19]
  \ProvidesClass{buaathesis}
                [2012/07/06 v0.8
  The LaTeX template for thesis of BUAA]
  \typeout{Document Class `buaathesis' v0.8 by BHOSC (2012/07)}

  ...

  \DeclareOption{twoteacher}{\buaa@twoteachertrue}
  % 其余选项传递给ctexbook
  \DeclareOption*{\PassOptionsToClass{\CurrentOption}{ctexbook}}
  \ProcessOptions\relax
  % 引用ctexbook及基本设置
  \LoadClass[cs4size,a4paper,fancyhdr]{ctexbook}[2007/10/19]

  %%%%%%%%%% global package %%%%%%%%%%
  % 全局通用宏包

  \RequirePackage{ifthen}

  \end{minted}
#+end_latex

1. \textbackslash{}NeedsTeXFormat
   specifies which version of TeX or LaTeX is required at least to run
   your package. The optional date may be used to specify the version
   more precisely.

2. \textbackslash{}ProvidesClass
   A package introduces itself using this command.
   1) <name> should be identical to the basename of the file itself.
   2) <version> should should begin with a date in the format
      YYYY/MM/DD. Version information should be kept updated while
      developing a package.

3. \textbackslash{}typeout

4. \textbackslash{}RequirePackage
   is equivalent to \textbackslash{}usepackage.

5. \textbackslash{}DeclareOptions
   are end-user parameters. Each option is declared by one such
   command.

6. \textbackslash{}ExecuteOptions{...}
   tells which are the default.

7. \textbackslash{}ProcessOptions\textbackslash{}relax
   terminates the option processing.

8. \textbackslash{}endinput
   this must be the last command(for package(.sty) not for class(cls)).

***** 选项
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
% 本模板自身包含五个选项
% 前四个为对应学位类型，决定不同样式
% 第五个为颜色选项，用于电子版的情况
\newif\ifbuaa@bachelor\buaa@bachelorfalse
\newif\ifbuaa@master\buaa@mastertrue
\newif\ifbuaa@engineer\buaa@engineerfalse
\newif\ifbuaa@doctor\buaa@doctorfalse
\newif\ifbuaa@color\buaa@colorfalse
\newif\ifbuaa@twoteacher\buaa@twoteacherfalse
\DeclareOption{bachelor}{\buaa@bachelortrue}
\DeclareOption{master}{\buaa@mastertrue}
\DeclareOption{engineer}{\buaa@engineertrue}
\DeclareOption{doctor}{\buaa@doctortrue}
\DeclareOption{color}{\buaa@colortrue}
\DeclareOption{twoteacher}{\buaa@twoteachertrue}
% 其余选项传递给ctexbook
\DeclareOption*{\PassOptionsToClass{\CurrentOption}{ctexbook}}
\end{minted}
#+end_latex

***** 字体与颜色
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \setmainfont{Times New Roman}
  % 不需要设置CJKmainfont，ctex 宏包已经很好的处理了
  % 不仅设置了粗体为黑体，斜体为楷体，还兼容了winfonts和adobefonts
  % 直接设置反而会在只有adobefonts的情况下报错
  % \setCJKmainfont{宋体}
  \setCJKfamilyfont{hwxingkai}{STXingkai}
  \newcommand{\hwxingkai}{\CJKfamily{hwxingkai}}
  \newcommand{\xiaochuhao}{\fontsize{32pt}{\baselineskip}\selectfont}

  %%%%%%%%%% color %%%%%%%%%%
  % 颜色设置

  % 只用于电子版
  \RequirePackage{color}
  \definecolor{dkgreen}{rgb}{0,0.6,0}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{mauve}{rgb}{0.58,0,0.82}
  \end{minted}
#+end_latex

1. \textbackslash{}setmintfont
2. \textbackslash{}newcommand{}{}
3. \textbackslash{}{}{}{}

***** 页边距
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \RequirePackage{geometry}
  \newgeometry{
      top=30mm, bottom=25mm, left=30mm, right=20mm,
      headsep=5mm,
  }
  \savegeometry{bachelorgeometry}
  \newgeometry{
      top=25mm, bottom=25mm, left=30mm, right=20mm,
      headsep=5mm, headheight=10mm, footskip=10mm,
  }
  \savegeometry{mastergeometry}

  \ifbuaa@bachelor
      \loadgeometry{bachelorgeometry}
  \else
      \loadgeometry{mastergeometry}
  \fi

  \end{minted}
#+end_latex

+ \textbackslash{}newgeometry
+ \textbackslash{}savegeometry
+ \textbackslash{}if...\textbackslash{}else...\textbackslash{}fi

***** 其它间距

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \renewcommand{\baselinestretch}{1.5}
  \setlength{\parindent}{2em}
  \setlength{\floatsep}{3pt plus 3pt minus 2pt}      % 图形之间或图形与正文之间的距离
  \setlength{\abovecaptionskip}{10pt plus 1pt minus 1pt} % 图形中的图与标题之间的距离
  \setlength{\belowcaptionskip}{3pt plus 1pt minus 2pt} % 表格中的表与标题之间的距离
  \end{minted}
#+end_latex

+ \textbackslash{}renewcommand
+ \textbackslash{}setlength

***** 汉化
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  \renewcommand{\contentsname}{目\qquad 录}
  \renewcommand\listfigurename{插\ 图\ 目\ 录}
  \renewcommand\listtablename{表\ 格\ 目\ 录}
  \renewcommand\bibname{参\ 考\ 文\ 献}
  \renewcommand{\figurename}{图}
  \renewcommand{\tablename}{表}
  \end{minted}
#+end_latex

***** 段落格式
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  % 格式
  \CTEXsetup[
      format={\centering\zihao{3}\heiti},
      nameformat={},
      aftername={\quad},
      titleformat={},
      beforeskip={-.5\baselineskip},
      afterskip={\baselineskip},
  ]{chapter}
  \CTEXsetup[
      aftername={\quad},
      beforeskip={.5\baselineskip},
      afterskip={.5\baselineskip},
  ]{section}
  \CTEXsetup[
      format={\zihao{-4}\heiti},
      aftername={\quad},
      beforeskip={.5\baselineskip},
      afterskip={.5\baselineskip},
  ]{subsection}
  \ifbuaa@bachelor
      \CTEXsetup[
          name={,},
          number={\arabic{chapter}},
      ]{chapter}
      \CTEXsetup[
          format={\zihao{-4}\heiti},
      ]{section}
  \else
      \CTEXsetup[
          name={第,章},
          number={\chinese{chapter}},
      ]{chapter}
      \CTEXsetup[
          format={\zihao{4}\heiti},
      ]{section}
  \fi

  \end{minted}
#+end_latex

***** 图片
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% picture %%%%%%%%%%
  % 图片

  \RequirePackage{graphicx}
  \DeclareGraphicsExtensions{.eps,.ps,.jpg,.bmp}
  \graphicspath{{figure/}}
  \RequirePackage{pifont} % “秘级”后的五角星
  \RequirePackage{subfigure}

  \end{minted}
#+end_latex

***** 列表
#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
%%%%%%%%%% list %%%%%%%%%%
% 列表

\RequirePackage{enumitem}
\setlist{noitemsep}
\setlist[1,2]{labelindent=\parindent}
\setlist[enumerate,1]{label=\arabic*、}
\setlist[enumerate,2]{label=（\arabic*）}
\setlist{
    topsep=0pt,
    itemsep=0pt,
    partopsep=0pt,
    parsep=\parskip,
}

\end{minted}
#+end_latex

***** 代码
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% code %%%%%%%%%%
  % 代码

  % Listing 的设置请参考 http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
  \RequirePackage{listings}
  \lstset{
      backgroundcolor=\color{white},
      basicstyle=\zihao{5}\ttfamily,
      columns=flexible,
      breakatwhitespace=false,
      breaklines=true,
      captionpos=b,
      frame=single,
      numbers=left,
      numbersep=5pt,
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      stepnumber=1,
      rulecolor=\color{black},
      tabsize=2,
      texcl=true,
      title=\lstname,
      escapeinside={\%*}{*)},
      extendedchars=false,
      mathescape=true,
      xleftmargin=3em,
      xrightmargin=3em,
  }
  \end{minted}
#+end_latex

***** 定理

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% theorem %%%%%%%%%%
  % 定理

  \theoremsymbol{\ensuremath{\square}}
  \newtheorem*{proof}{证明}
  \theoremstyle{plain}
  \theoremsymbol{}
  \theoremseparator{：}
  \newtheorem{assumption}{假设}[chapter]
  \newtheorem{definition}{定义}[chapter]
  \newtheorem{proposition}{命题}[chapter]
  \newtheorem{lemma}{引理}[chapter]
  \newtheorem{theorem}{定理}[chapter]
  \newtheorem{axiom}{公理}[chapter]
  \newtheorem{corollary}{推论}[chapter]
  \newtheorem{exercise}{练习}[chapter]
  \newtheorem{example}{例}[chapter]
  \newtheorem{remark}{注释}[chapter]
  \newtheorem{problem}{问题}[chapter]
  \newtheorem{conjecture}{猜想}[chapter]
  \end{minted}
#+end_latex

***** 标题

#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  %%%%%%%%%% caption %%%%%%%%%%
  % 图表标题

  \RequirePackage{caption}
  \DeclareCaptionFormat{bachelorfigure}{\songti\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{bachelortable}{\heiti\bf\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{bachelorlstlisting}{\songti\bf\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{masterfigure}{\bf\songti\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{mastertable}{\bf\songti\zihao{5}{#1\textrm{#2}#3}}
  \DeclareCaptionFormat{masterlstlisting}{\bf\songti\zihao{5}{#1\textrm{#2}#3}}
  \ifbuaa@bachelor
      \captionsetup[figure]{format=bachelorfigure,labelsep=quad}
      \captionsetup[table]{format=bachelortable,labelsep=quad}
      \captionsetup[lstlisting]{format=bachelorlstlisting,labelsep=quad}
      \renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}}
      \renewcommand{\thetable}{\arabic{chapter}.\arabic{table}}
      \renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}
  \else
      \RequirePackage{remreset}
      \@removefromreset{table}{chapter}
      \@removefromreset{figure}{chapter}
      %使图表的标号与章节无关
      \captionsetup[figure]{format=masterfigure,labelsep=quad}
      \captionsetup[table]{format=mastertable,labelsep=quad}
      \captionsetup[lstlisting]{format=masterlstlisting,labelsep=quad}
      \renewcommand{\thefigure}{\arabic{figure}}
      \renewcommand{\thetable}{\arabic{table}}
      \renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}
  \fi
  \end{minted}
#+end_latex

***** 页码
#+begin_latex
  \begin{minted}[frame=single, mathescape]{latex}
  % 正文前的页码设置位大写罗马数字
  \renewcommand{\frontmatter}{
      \cleardoublepage
      \@mainmatterfalse
      \ifbuaa@bachelor
          \pagenumbering{Roman}
      \else
          \pagenumbering{roman}
      \fi
  }

  % 保证偶数页结束章节
  \newcommand{\clearemptydoublepage}{%
      \clearpage
      \if@twoside
          \ifodd
              \c@page
          \else
              \hbox{}\thispagestyle{empty}\newpage
              \if@twocolumn
                  \hbox{}\newpage
              \fi
          \fi
      \fi
  }
  \end{minted}
#+end_latex

***** 首页
好长！

#+begin_latex
\begin{minted}[frame=single, mathescape]{latex}
% 中文首页
\newcommand{\titlech}{
....
}

% 英文首页
\newcommand{\titleeng}{
....
}
\end{minted}
#+end_latex

***** 摘要
#+begin_latex
% 中文摘要
\begin{minted}[frame=single, mathescape]{latex}
\newenvironment{cabstract}{
...
}

% 英文摘要
\newenvironment{eabstract}{
...
}
\end{minted}
#+end_latex

***** 其它
+ 声明
+ 任务书
+ 授权页
+ 用户信息

**** LaTeX 论文

***** 测试 ctex 和 winfonts 选项

#+BEGIN_SRC latex
\documentclass{article}
\usepackage[winfonts]{ctex}
\begin{document}
中文
\end{document}
#+END_SRC

编译有警告，可以生成 PDF

***** 测试 buaathesis 作为 org latex 文类

1. 配置

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-latex-classes
                  '("buaathesis" "\\documentclass{buaathesis}
       [NO-DEFAULT-PACKAGES]
       [NO-PACKAGES]"))
   #+END_SRC

2. 测试 org

   #+BEGIN_SRC org
     ,#+LaTeX_class: buaathesis

     中文
   #+END_SRC

3. 生成 latex

   #+BEGIN_SRC latex
     % Created 2015-12-28 一 10:00
     \documentclass{buaathesis}
     \usepackage[utf8]{inputenc}
     \usepackage[T1]{fontenc}
     \usepackage{fixltx2e}
     \usepackage{graphicx}
     \usepackage{longtable}
     \usepackage{float}
     \usepackage{wrapfig}
     \usepackage{rotating}
     \usepackage[normalem]{ulem}
     \usepackage{amsmath}
     \usepackage{textcomp}
     \usepackage{marvosym}
     \usepackage{wasysym}
     \usepackage{amssymb}
     \usepackage{capt-of}
     \usepackage{hyperref}
     \tolerance=1000
     \usepackage{minted}
     \author{ben}
     \date{\today}
     \title{}
     \hypersetup{
      pdfauthor={ben},
      pdftitle={},
      pdfkeywords={},
      pdfsubject={},
      pdfcreator={Emacs 24.4.1 (Org mode 8.3beta)},
      pdflang={English}}
     \begin{document}

     \tableofcontents

     中文
     \end{document}
   #+END_SRC

4. 分析

   1) 编译 LaTeX 文档，可以生成 PDF，有如下错误(error)

      #+BEGIN_EXAMPLE
        ! LaTeX Error: Option clash for package ulem.
      #+END_EXAMPLE

     原因： ulem宏包选项冲突， org导出的LaTeX文件中默认包含
      =\usepackage[normalem]{ulem}= 与 buaathesis 中设置冲突，注释后无
      错误。

   2) 如何配置 org latex 使其导出的 latex 文件零配置
      - 不默认包含使用各种宏包（OK）
      - 不默认生成目录（手动删除）
      - 不默认生成作者、日期等信息（手动删除）

   3) 导出的标题层次不对, 即 一级标题没有导出为 \chapter

***** 空格

***** 章节条

[[/home/ben/Wally/Journal//Figure/scrot/3959tpl.png]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-classes
               '("buaathesis" "\\documentclass{buaathesis}
    [NO-DEFAULT-PACKAGES]
    [NO-PACKAGES]
    [NO-EXTRA]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ))
#+END_SRC
***** 图片
***
***** 论文中如何引用网页

[[/home/ben/Wally/Journal//Figure/scrot/3769ZXh.png]]

[[/home/ben/Wally/Journal//Figure/scrot/3769mhn.png]]

http://tex.stackexchange.com/questions/3587/how-can-i-use-bibtex-to-cite-a-web-page

A simple way of doing it in BibTeX is with a @misc entry:

#+BEGIN_EXAMPLE
@misc{WinNT,
  title = {{MS Windows NT} Kernel Description},
  howpublished = {\url{http://web.archive.org/web/20080207010024/http://www.808multimedia.com/winnt/kernel.htm}},
  note = {Accessed: 2010-09-30}
}
#+END_EXAMPLE

You should also perhaps include an author if you know it. And remember to load a package such as hyperref or url.

If you are using BibLaTeX there is an @online entry type:

#+BEGIN_EXAMPLE
  @online{WinNT,
    author = {MultiMedia LLC},
    title = {{MS Windows NT} Kernel Description},
    year = 1999,
    url = {http://web.archive.org/web/20080207010024/http://www.808multimedia.com/winnt/kernel.htm},
    urldate = {2010-09-30}
  }
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  @misc{ROS,
  title={Robot Operating System},
  howpublished={\url{http://www.ros.org/wiki}},
  note={online}
  }

  @mics{Gazebo,
  title={Gazebo}
  howpublished={\url{http://http://www.gazebosim.org/}},
  note{online}}
#+END_EXAMPLE

**** 参考文献                                             :latex:参考文献:
***** bibtex                                                     :bibtex:
****** 格式

格式如下：
+ 以用{}包含具体内容

  #+BEGIN_EXAMPLE
    @article {name1,
    author = {作者, 多个作者用 and 连接},
    title = {标题},
    journal = {期刊名},
    volume = {卷20},
    number = {页码},
    year = {年份},
    }
#+END_EXAMPLE

+ 也可以直接用双引号“”包含具体内容
  #+BEGIN_EXAMPLE
    @book {name2,
    author ="作者",
    year ="年份2008",
    title ="书名",
    publisher ="出版社名称"
    }
#+END_EXAMPLE

****** bibtex支持的参考文献的条目：

|--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Item　       | 说明                                                                                                                                                                                                                                                                      |
|--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| address      | Publisher's address (usually just the city, but can be the full address for lesser-known publishers)                                                                                                                                                                      |
| annote       | An annotation for annotated bibliography styles                                                                                                                                                                                                                           |
| author       | The name(s) of the author(s) (in the case of more than one author, separated by and )                                                                                                                                                                                     |
| booktitle    | The title of the book, if only part of it is being cited                                                                                                                                                                                                                  |
| chapter      | The chapter number                                                                                                                                                                                                                                                        |
| crossref     | The key of the cross-referenced entry                                                                                                                                                                                                                                     |
| edition      | The edition of a book, long form (such as "first" or "second")                                                                                                                                                                                                            |
| editor       | The name(s) of the editor(s)                                                                                                                                                                                                                                              |
| eprint       | A specification of an electronic publication, often a preprint or a technical report                                                                                                                                                                                      |
| howpublished | How it was published, if the publishing method is nonstandard                                                                                                                                                                                                             |
| institution  | The institution that was involved in the publishing, but not necessarily the publisher                                                                                                                                                                                    |
| journal      | The journal or magazine the work was published in                                                                                                                                                                                                                         |
| key          | A hidden field used for specifying or overriding the alphabetical order of entries (when the "author" and "editor" fields are missing). Note that this is very different from the key (mentioned just after this list) that is used to cite or cross-reference the entry. |
| month        | The month of publication (or, if unpublished, the month of creation)                                                                                                                                                                                                      |
| note         | Miscellaneous extra information                                                                                                                                                                                                                                           |
| number       | The "number" of a journal, magazine, or tech-report, if applicable. (Most publications have a "volume", but no "number" field.)                                                                                                                                           |
| organization | The conference sponsor                                                                                                                                                                                                                                                    |
| pages        | Page numbers, separated either by commas or double-hyphens. For books, the total number of pages.                                                                                                                                                                         |
| publisher    | The publisher's name                                                                                                                                                                                                                                                      |
| school       | The school where the thesis was written                                                                                                                                                                                                                                   |
| series       | The series of books the book was published in (e.g. "The Hardy Boys " or "Lecture Notes in Computer Science ")                                                                                                                                                            |
| title        | The title of the work                                                                                                                                                                                                                                                     |
| type         | The type of tech-report, for example, "Research Note"                                                                                                                                                                                                                     |
| url          | The WWW address                                                                                                                                                                                                                                                           |
| volume       | The volume of a journal or multi-volume book                                                                                                                                                                                                                              |
| year         | The year of publication (or, if unpublished, the year of creation)                                                                                                                                                                                                        |
|--------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

***** TeX 参考文献
参考:
+ [[https://app.yinxiang.com/shard/s52/nl/11551545/f5d953dd-91d8-4a1c-8dde-df6de5ba4921/?csrfBusterToken%3DU%253Db04339%253AP%253D%252F%253AE%253D1518f3e68f6%253AS%253Df642656b79ac72e805f2499d73c28c2b][LaTeX 对参考文献的管理]]
+ [[http://xb9he.bokee.com/6688578.html][TeX 参考文献]]

****** bibtex

经常写作论文的人都知道，多篇论文可能引用同一篇参考文献。如果每篇论文都
要键入此一文献，不仅费时，也容易犯错。

BibTeX 是 LaTeX 自带的一个辅助程序，启动时自动加载。它可根据文献引用处
出提供的检索名（如 \ cite{Huetal2000}），搜索一个或多个文献数据库，然后
在文件末尾创建参考文献。如果以后编写其它文件用到相同的参考文献时还可调
用这些文献数据库。图为 BibTeX 的徽标。

[[/home/ben/Wally/Journal/Figure/1503022216.png]]

可通过命令

#+BEGIN_EXAMPLE
  \bibliography{文献数据库名}
  \bibliographystyle{选项}
#+END_EXAMPLE

****** 标准选项
预先设置要检索的文献数据库以及文献引用与文献列表的样式，LaTeX 标准选项
及其样式共有以下8种：

******* plain，按字母的顺序排列，比较次序为作者、年度和标题：
[[~/Wally/Journal/Figure/1503022216-2.png]]

******* unsrt，样式同plain，只是按照引用的先后排序：
[[~/Wally/Journal/Figure/1503022216-3.png]]

******* alpha，用作者名首字母+年份后两位作标号，以字母顺序排序：
[[~/Wally/Journal/Figure/1503022216-4.png]]

******* abbrv，类似plain，将月份全拼改为缩写，更显紧凑：
[[~/Wally/Journal/Figure/1503022216-5.png]]

******* ieeetr，国际电气电子工程师协会期刊样式：
[[~/Wally/Journal/Figure/1503022216-6.png]]

******* acm，美国计算机学会期刊样式：
[[~/Wally/Journal/Figure/1503022216-7.png]]

******* siam，美国工业和应用数学学会期刊样式：
[[~/Wally/Journal/Figure/1503022216-8.png]]

******* apalike，美国心理学学会期刊样式：
[[~/Wally/Journal/Figure/1503022216-9.png]]

文献数据库可根据要求自行编写，其格式有：文章、书籍、技术报告、会议论文
集和博士论文等十几种，每种格式都有一些必填和选填的项目，如作者、标题、
出版社、发表年度、...等等，最后存储为 .bib 文件。

如果对生成的参考文献样式仍有不满意之处，还可将编译信息文件*.bbl 中的参
考文献列表源程序拷贝到论文尾部，然后进行手工调整。

****** bib文件
可以维护一个 bib 文件，在你的整个研究生涯可以只维护这样一个文件，就象
一个数据库，每个参考文献是一个记录，由一个唯一的 ID （例如下面的
MartinDSP00）描述。

比如我的 myreference.bib 文件里一条典型的文献是这样的：
#+BEGIN_EXAMPLE
  @article{MartinDSP00,
       author = "A. Martin and M. Przybocki",
       title = "The {NIST} 1999 speaker recognition evaluation --- an overview",

       journal = "Digital Signal Processing",
       volume = "10",
       pages = "1--18",
       year = "2000",}
#+END_EXAMPLE

其中 {NIST} 中的大括号不会被显示，它的作用是保证将来的生成的参考文献中
NIST 四个字保持原样，不会被小写。

****** 文献库引用

 需要引用文献的时候，在正文里加入：
 #+BEGIN_EXAMPLE
   \bibliographystyle{ieeetr}
   \bibliography{myreference}
 #+END_EXAMPLE

注:  /在正文中使用,而非导言中,一般放在tex文件尾部,在此生成参考文献/

就可以用 *cite{}* 来引用文献库中的论文了，如 cite{MartinDSP00}。上面第
一行是控制文献显示格式的，这个后面再讲。此时，myreference.bib 文件在正
文tex 文件的同一目录下，以保证 LaTeX 可以找到该 bib 文件。

****** 编译

BibTeX 提供了一个外部的 BibTeX 工具程序，源文件经过 LaTeX 编译后，还要
使用BibTeX 对数据库文件编译一次，最后再用 LaTeX 连续编译两遍，才能得到
正确结果。 可用下图解释这四个编译步骤的作用：

[[~/Wally/Journal/Figure/1503022216-A.png]]

1) 编译正文，生成 aux 文件
2) 然后用 bibtex 在当前目录生成 bbl 文件
3) 再编译正文两次，完整的 dvi 就生成了。

这样，LaTeX 保证了所有用 cite 引用到的文献都已被列出，并且自动编号。同
时，如果没有用ocite 命令，LaTeX 还保证所有列出的参考文献都在正文中得到
了引用。

****** bib 文件维护

*bib 文件把 @ 所定义的 entry 之外的所有东西看作是注释。* 比如在上面
@article 的例子里，如果我在大括号之外写些东西的话，bibtex 是不会关心的，
就当它不存在。所以可以把文献的关键字写在这里，将来通过搜索关键字来查找
某些文献。

*更好的选择是使用ORG-MODE进行管理bib文件*

其实也可以搞一个临时的LaTeX 文件，使用ocite{*} 命令，然后编译成 dvi，
这样就得到了一个 bib 文件中所有参考文献的列表，当然是可以按照作者名字
排序的。

另外，很多 journal（学术期刊）或者 booktitle（国际会议）都是重复的，为
了规范化，可以定义缩写，如
#+BEGIN_EXAMPLE
  @string(ICASSP = "Proc. of the International Conference on Acoustics,
          Speech,and Signal Processing (ICASSP)")
#+END_EXAMPLE

这样在执行 bibtex 之后，ICASSP 会被替换成它的全称。
#+BEGIN_EXAMPLE
  @conference{QL.ICA98,
       author = "Qi Li and Biing-Hwang Juang",
       title   = "Speaker Verification Using Verbal Information Verification for Automatic Enrollment",
       booktitle = ICASSP,
       year = "1998",}
#+END_EXAMPLE

****** bib 中的中文文献

中文文献和英文的格式不同，并且使用全角的标点符号，有一点难办。我的解决
办法是这样的：

#+BEGIN_EXAMPLE
  @misc{Xie.1995,
        note = "谢锦辉，《隐 {Markov} 模型及其在语音处理中的应用》，华中理工大学出版社，1995年4月",
        key = "Xie",}

#+END_EXAMPLE

唯一的缺陷是参考文献中最后是以英文的 "." 而不是 "。" 结束的。还好我的

中文文献不多，无伤大雅，否则就 *手工修改一下 bbl 文件* 吧。

****** 关于参考文献的显示格式、排序，及其他

是通过一些 *bst* 文件来控制的。而使用哪种 bst 格式，可通
过 *bibliographystyle* 命令控制。LaTeX 默认提供了这么几种格式，如：
plain、alpha、unsrt。具体意义见相关文档，这些bst 在 texmf/ibtex/st/ase
可被找到。

bst 控制的格式非常细致

+ 排序方式
  - 以正文中引用顺序排序
  - 以文献第一作者的 last name 排序
+ 引用序号是 LaTeX 提供的 ID 还是数字的
+ 作者名字是否用缩写
+ 作者名字放在文献的起始还是结束
+ 文章 title 要不要大小写（即 "Speaker Verification Using ..." 还是 "Speaker verification using "）
+ title 用什么区分（用不用引号括起来，用不用斜体等）
+ 刊物名字的格式（要不要全部大写，要不要粗体，要不要斜体，要不要括起来）
  等等等等。

打开 bst 文件看一下就知道，绝对是想要什么形式，就可以得到什么形式。最
关键的是，在文章定稿之后，完全可以用几个命令重新定义参考文献的格式！

****** 如何定制参考文献的显示格式

其实 bst 文件有很多，总能找到自己需要的。如果这些还不能满足，可以通过
生成自己的 bst 文件来定制。这有两个方法，第一是手写（反正我是写不出来），
第二是通过工具。 *custom-bib* 是一个定制 bst 文件的包，解压缩后用 LaTeX
编译其中的主 tex 文件，便会进行交互式的 bst 定制过程，具体过程我就不讲
了。把生成的自定义的 bst 放到 LaTeX 相应目录下，刷新文件名数据库就可以
使用了。

***** LaTeX 参考文献

****** 参考文献
******* What

参考文献是作者在从事科学研究过程中和在撰写论文中,直接或间接使用他人科
研成果或引用他人学术论著而做的标记.参考文献的内容包括专著及其析出文献,
连续出版物及其析出文献,专利文献和电子文献等文献资料信息.

******* 位置

正文之后,索引之前.

******* 意义

+ 体现科学技术的发展历程及其继承性
+ 尊重和保护他人的著作权
+ 简化论述,缩短论文篇幅
+ 指明理论依据
+ 与读者共享相关信息资源

****** 参考文献环境

标准文类book等都提供可以排版参考文献的 *thebibliography* 的 *列表*环
境, 及在该环境中使用的 *\textbackslash{}bibitem* 文献 *条目* 命令.

#+BEGIN_EXAMPLE
  \begin{thebibliography}{最大序号}
  \bibitem[文献序号]{检索名} 文献信息
    ...
  \end{thebibliography}
#+END_EXAMPLE

参数说明:
+ 最大序号: 测定文献序号最大宽度,通常一位用9,两位用99
+ 文献序号: 可选参数,自行设定文献序号,通常省略
+ 检索名: 正文中 *\textbackslash{}label* 引用文献的唯一标识
+ 文献信息:

注: 不同文类
+ book/report: 使用章命令 \textbackslash{}chapter* 创建以 *Bibliography* 为标题的一章
+ article: 使用节命令 \textbackslash{}section* 生成以 *Reference* 为题的一节

建议: *为了便于记忆和防止混淆,通常采用作者姓氏加上出版年份的后两位作为*
*每个参考文献的检索名.* 如Lamport98

****** 参考文献的引用

如果要在正文中引用参考文献列表中的文献时,可丰引文之后使用 *文献引用命
令 \textbackslash{}cite*

#+BEGIN_EXAMPLE
  \cite[附加信息]{检索名1,检索名2,...}
#+END_EXAMPLE

参考文献的引用也是一种 *交叉引用*, 源文件需多次编译.

****** 引用格式的修改

宏包: *cite*
#+BEGIN_EXAMPLE
  \usepackage[格式]{cite}
#+END_EXAMPLE

****** 文献信息分段

启用文类的 *openlib* 选项.
文献棩中使用 *\newblock* 命令.

***** [[http://purpletulipdyc.blog.sohu.com/259698858.html][引用多个参考文献]]

如果在文章中出现连续引用多个参考文献的情况，希望显示的格式为 [1-9].在
文章的导言区加

#+BEGIN_SRC latex
\usepackage{cite}
#+END_SRC

在文章正文中需要引用参考文献的地方使用：

#+BEGIN_SRC latex
\cite{liu2012, wen13,wang2010VTC,shen2008ICC,Alex2007ICC}
#+END_SRC

***** 不要使用 org-mode 维护 bib 文件

error

#+BEGIN_EXAMPLE
I couldn't open database file /home/ben/Wally/GraduationProject/Thesis/literature.org.bib
#+END_EXAMPLE

***** [[https://app.yinxiang.com/SetAuthToken.action?auth=S%3Ds52%3AU%3Db04339%3AE%3D151a0dccd97%3AC%3D151a0a5df17%3AP%3D195%3AA%3Den-chrome-clipper-xauth-new%3AV%3D2%3AH%3D5522a9e07f0c5aab83cf036e36eb2457&targetUrl=%2Fshard%2Fs52%2Fnl%2F11551545%2F2208e3d2-a67b-4620-bc54-855bfaaf5192%2F][引用参考文献时使用上标]]

1. 默认情况下 LaTeX 不使用上标

   [[/home/ben/Wally/Journal/Figure/scrot/24567oOO.png]]

2. /cite/ 宏包的 /superscript/ 选项

   #+begin_latex
     \begin{minted}[frame=leftline, mathescape]{latex}
     \usepackage[superscript]{cite}
     \end{minted}
   #+end_latex

   [[/home/ben/Wally/Journal/Figure/scrot/24567c3m.png]]

   没有使用方括号

3. 修改 sty 文件

4. 解决 /BUAAthesis模板中定义得很好/

** TAGERILL
*** model

1. joint类型为continuous时，显示wheel与base的transform出错，改成fixed则没
   有问题，why?

   continuous 类型joint需要joint_state_publisher发布
   joint_states(sensor_msgs/JointState)

   开启节点： <node name="joint_state_publisher"
   pkg="joint_state_publisher" type="joint_state_publisher" />

   pub: JointState

2. package: robot_state_publisher node: state_publisher ?
   *robot_state_publisher*

*** move_control
**** TODO kobuki.launch.xml  control部分

+ kobuki.launch.xml  control部分
  #+BEGIN_SRC xml
    <launch>
      <arg name="base"/>
      <arg name="stacks"/>
      <arg name="3d_sensor"/>

      <!-- <arg name="urdf_file" default="$(find xacro)/xacro.py '$(find turtlebot_description)/robots/$(arg base)_$(arg stacks)_$(arg 3d_sensor).urdf.xacro'" /> -->
      <arg name="urdf_file" default="$(find xacro)/xacro.py '$(find turtlebot_description)/robots/kobuki_hexagons_kinect.urdf.xacro'" />
      <param name="robot_description" command="$(arg urdf_file)" />

      <!-- Gazebo model spawner -->
      <node name="spawn_turtlebot_model" pkg="gazebo_ros" type="spawn_model"
            args="$(optenv ROBOT_INITIAL_POSE) -unpause -urdf -param robot_description -model mobile_base"/>

      <!-- Velocity muxer -->
      <node pkg="nodelet" type="nodelet" name="mobile_base_nodelet_manager" args="manager"/>
      <node pkg="nodelet" type="nodelet" name="cmd_vel_mux"
            args="load yocs_cmd_vel_mux/CmdVelMuxNodelet mobile_base_nodelet_manager">
        <param name="yaml_cfg_file" value="$(find turtlebot_bringup)/param/mux.yaml" />
        <remap from="cmd_vel_mux/output" to="mobile_base/commands/velocity"/>
      </node>

      <!-- Bumper/cliff to pointcloud (not working, as it needs sensors/core messages) -->
      <include file="$(find turtlebot_bringup)/launch/includes/kobuki/bumper2pc.launch.xml"/>
    </launch>

  #+END_SRC

+ kobuki gazebo
  #+BEGIN_SRC xml
    <gazebo>
      <plugin name="kobuki_controller" filename="libgazebo_ros_kobuki.so">
        <publish_tf>1</publish_tf>
        <left_wheel_joint_name>wheel_left_joint</left_wheel_joint_name>
        <right_wheel_joint_name>wheel_right_joint</right_wheel_joint_name>
        <wheel_separation>.230</wheel_separation>
        <wheel_diameter>0.070</wheel_diameter>
        <torque>1.0</torque>
        <velocity_command_timeout>0.6</velocity_command_timeout>
        <cliff_sensor_left_name>cliff_sensor_left</cliff_sensor_left_name>
        <cliff_sensor_center_name>cliff_sensor_front</cliff_sensor_center_name>
        <cliff_sensor_right_name>cliff_sensor_right</cliff_sensor_right_name>
        <cliff_detection_threshold>0.04</cliff_detection_threshold>
        <bumper_name>bumpers</bumper_name>
        <imu_name>imu</imu_name>
      </plugin>
    </gazebo>
  #+END_SRC

  - 位置：.ckws/devel/lib/libgazebo_ros_kobuki.so
**** 先研究ros_control, 再琢磨自己写控制lib

*** gmapping
+ turtlebot_gazebo gmapping_demo.launch
  #+BEGIN_SRC xml
  <launch>
    <include file="$(find turtlebot_navigation)/launch/includes/gmapping.launch.xml"/>
  </launch>
  #+END_SRC

+ turtlebot_navigation gmapping.launch.xml
  #+BEGIN_SRC xml
      <launch>
      <arg name="scan_topic"  default="scan" />
      <arg name="base_frame"  default="base_footprint"/>
      <arg name="odom_frame"  default="odom"/>

      <node pkg="gmapping" type="slam_gmapping" name="slam_gmapping" output="screen">
        <param name="base_frame" value="$(arg base_frame)"/>
        <param name="odom_frame" value="$(arg odom_frame)"/>
        <param name="map_update_interval" value="5.0"/>
        <param name="maxUrange" value="6.0"/>
        <param name="maxRange" value="8.0"/>
        <param name="sigma" value="0.05"/>
        <param name="kernelSize" value="1"/>
        <param name="lstep" value="0.05"/>
        <param name="astep" value="0.05"/>
        <param name="iterations" value="5"/>
        <param name="lsigma" value="0.075"/>
        <param name="ogain" value="3.0"/>
        <param name="lskip" value="0"/>
        <param name="minimumScore" value="200"/>
        <param name="srr" value="0.01"/>
        <param name="srt" value="0.02"/>
        <param name="str" value="0.01"/>
        <param name="stt" value="0.02"/>
        <param name="linearUpdate" value="0.5"/>
        <param name="angularUpdate" value="0.436"/>
        <param name="temporalUpdate" value="-1.0"/>
        <param name="resampleThreshold" value="0.5"/>
        <param name="particles" value="80"/>
      <!--
        <param name="xmin" value="-50.0"/>
        <param name="ymin" value="-50.0"/>
        <param name="xmax" value="50.0"/>
        <param name="ymax" value="50.0"/>
      make the starting size small for the benefit of the Android client's memory...
      -->
        <param name="xmin" value="-1.0"/>
        <param name="ymin" value="-1.0"/>
        <param name="xmax" value="1.0"/>
        <param name="ymax" value="1.0"/>

        <param name="delta" value="0.05"/>
        <param name="llsamplerange" value="0.01"/>
        <param name="llsamplestep" value="0.01"/>
        <param name="lasamplerange" value="0.005"/>
        <param name="lasamplestep" value="0.005"/>
        <remap from="scan" to="$(arg scan_topic)"/>
      </node>
    </launch>

  #+END_SRC

*** rviz error

自己配置的rviz不但模型不是平面的，而且不会动

使用别人的，这两个问题同时得到了解决。

原因是没有 Listen tf

*** 增加 pan-and-tilt
*** 关于display.launch

#+BEGIN_SRC xml
  <launch>
          <arg name="model" default="$(find xacro)/xacro.py '$(find tagerill_description)/urdf/tagerill.urdf.xacro'"/>
          <arg name="gui" default="False" />
          <param name="robot_description" command="$(arg model)" />
          <param name="use_gui" value="$(arg gui)"/>
          <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher" />
          <node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher" />
          <node name="rviz" pkg="rviz" type="rviz" args="-d $(find tagerill_description)/rviz/urdf.rviz" required="true" />
  </launch>
#+END_SRC

Note1: 有时在其它roslaunch中修改了某些ros param, 可能会使模型加载失败

*** kinect

**** 目标

1. 学会在仿真中使用Kinect
   1) 建立urdf模型，并使用rviz显示出来
   2) 在Gazebo中仿真并与ROS通信

2. 测试 depthimage_to_laserscan 以及 nodelet

*** 新的模型 *Holonomic*
**** ROS answer: Holonomic mobile base using Gazebo
+
  http://answers.ros.org/question/30629/holonomic-mobile-base-using-gazebo/


The base platform containing of four wheels, each wheel has 2 degrees
of freedom. It is a holonomic wheel base. There are two motors
connected to each wheel, one is used for steering and the other is
used for driving. The wheel is no deformable planar circle
type. Therefore, each wheel has the capability of steering and driving
independently.


From what I understand, this is the same configuration used by the PR2
and the Care-O-Bot. You can therefore have a look at these packages
for inspiration/reference.

PR2 VS Care-O-Bot: Of course,  *PR2*.

*** Mecanum

**** how

https://github.com/micpalmia/youbot_ros_tools/issues/5

It's a really interesting simulation issue.

First of all, let's a look at the wheels. They are not standard
wheels, they are mecanum wheels. This kind of wheels help the robot to
move and rotate easily in any directions, even in congested area. The
movement come from the resulting rotation speeds of the wheels, which
are independent. I have found I nice explanation of the relationship
between the wheels rotation and the resulting movement on this lego
page. On the videos, the youBot looks like gliding on the ground.

From a design point of view, this is convenient, because it is similar
to a planar joint + a revolute joint between the base and the
ground. Very easy to control.

From a simulation point of view, it is a nightmare.

I doubt that the repo from youBot or WPI-RAIL did the job, because
they involve casters. And there is no casters on the real KUKA
youBot. If you have a look at their teleop program, you will see that
this program align the wheels before the rotation, which is not the
design of a mecanum wheel at all. With the mesh of the wheels, you
will see it. This not natural (this is also why the wheels solid shape
is a sphere). And even worst, the the rotation is therefore not
supported. So for me, this model is really poor.

I raised the question on Gazebo answers. Someone suggested to use this
planar controller. I considered it as a second choice, but finally,
this is very close to the behavior of the real mecanum wheels, as you
define the x/y velocity and rotation, which can be directly linked to
the wheel individual speeds. I have remove the friction between the
wheels and the ground.

On the real robot, this x/y speed and rotation translation to
individual wheels speeds would also be very convenient.

A visually better solution would be to add the mesh of the wheels, and
rotate them according to the planar messages. No time to work on this.

Finally, if you are looking for a very physical solution, I have found
this link, where it has been done in another simulator, by mixing
kinematics and dynamics solutions.

That would be really great to have more realistic solution. For my
requirement, the planar controller is enough.

*** [pcl::SampleConsensusModelPlane::optimizeModelCoefficients] Not enough inliers found to support a model (0)! Returning the same coefficients.
+
  http://answers.ros.org/question/30909/problem-with-feeding-pointcloud2-messages-from-swissranger-4000-to-octomap-server/


Do you actually need the built-in ground plane filter? For mere map
building there's usually no need and you can set the parameter
~filter_ground to false. By default (in the latest version of
octomap_server), it should be false.

Otherwise you usually need to adjust the PCL plane detection
parameters to your sensor, it is currently tuned to the PR2's stereo
camera by default. Best have a look at the code, not all parameters
are explained on the wiki site in detail.

** wally

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/README.md
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/ChangeLog.org

*** TODOs

**** map merge

http://answers.ros.org/question/133486/how-can-i-merge-some-maps/
http://wiki.ros.org/map_merger
http://answers.ros.org/question/187855/connecting-maps/

*** wally stack

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally/package.xml :src xml

*** wally_description
**** package

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/package.xml :src xml

**** wally.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro :src xml

**** display.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_description/launch/display.launch :src xml

***** 测试 node 标签的 doc 属性，进行文档化工作

#+BEGIN_EXAMPLE
  test $ roslaunch --ros-args wally_description display.launch
  Optional Arguments:
    gui (default "false"): undocumented
    model (default "/opt/ros/indigo/share/xacro/xacro.py /home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro"): undocumented
    xacro (default "/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro"): xacro文件， default '/home/ben/Wally/Project/catkin_ws/src/wally/wally_description/urdf/wally.xacro'

#+END_EXAMPLE

***** 测试 node 标签中的 required 属性

#+BEGIN_EXAMPLE
  test $ rosnode list
  /joint_state_publisher
  /robot_state_publisher
  /rosout
  /rviz
  test $ rosnode kill rviz
  killing /rviz
  killed
  test $ rosnode list
  /rosout
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  ================================================================================
  REQUIRED process [rviz-3] has died!
  process has finished cleanly
  log file: /home/ben/.ros/log/466aa446-9439-11e5-bfff-002186ef9d91/rviz-3*.log
  Initiating shutdown!
  ================================================================================

#+END_EXAMPLE

***** 测试 display 是否对 hokuyo.xacro [嵌套的层不要太多]

失败，hokuyo.xacro本身不会生成完整的urdf文件，除非指定参数alpha为true
*** wally_bringup

**** package
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_bringup/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_bringup/package.xml :src xml

*** wally_gazebo
**** package

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_gazebo/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_gazebo/package.xml :src xml

**** wally_gazebo.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_gazebo/launch/wally_gazebo.launch :src xml

*** wally_launch
**** package

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/CMakeLists.txt :src cmake
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/package.xml :src xml

**** nav

***** move_base

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/move_base.launch :src xml

****** TODO configs <参数含义>

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/base_local_planner_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/costmap_common_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/global_costmap_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/local_costmap_params.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/config/nav_obstacles_params.yaml :src yaml

**** wally.launch
#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/wally.launch :src xml
**** gmapping.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/gmapping.launch :src xml

**** sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/sim.launch :src xml

**** DONE filter.launch
- State "DONE"       from "NEXT"       [2016-01-05 二 14:31] \\
  ok了，在解决 laser_assembler 问题的同时找到了 filters 的答案，原因在于 clock
- State "NEXT"       from ""           [2016-01-01 五 16:42] \\
  laser_filter 还是存在问题！！!
  先不管它。

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/laser_filter.launch :src xml

*scan_to_scan_filter_chain*

*scan_to_cloud_filter_chain*

filters

- LaserArrayFilter
- [X] LaserIntensityFilter
- [X] ScanShadowsFilter
- [X] InterpolationFilter
- [X] LaserScanRangeFilter


laser_filters 的源码编译问题再重新安装系统后解决。问题并不在于 catkin
的配置问题，而是系统库的问题。

**** laser_assembler.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/laser_assembler.launch :src xml


***** laser_assembler_pointcloud

#+include: ~/Wally/Project/catkin_ws/src/wally/wally_launch/src/laser_assembler_pointcloud2.cpp

1. call laser_assembler service:

   #+BEGIN_SRC cpp
      AssembleScans srv;
     srv.request.begin = e.last_real;
     srv.request.end = e.current_real;

     if(client_.call(srv)){
       // ROS_INFO("Published Cloud with %u points", (uint32_t)(srv.response.cloud.points.size()));
       pub_.publish(srv.response.cloud);
      }
   #+END_SRC

2. 周期性地发布点去消息（时间驱动）

   #+BEGIN_SRC cpp
     timer_ = n_.createTimer(ros::Duration(15, 0), &PeriodicSnapshotter::timerCallback, this);
   #+END_SRC

***** pointcloud & pointcloud2

sensor_msgs/PointCloud.msg

#+BEGIN_EXAMPLE
  std_msgs/Header header
  geometry_msgs/Point32[] points
  sensor_msgs/ChannelFloat32[] channels
#+END_EXAMPLE

sensor_msgs/PointCloud2.msg
#+BEGIN_EXAMPLE
  std_msgs/Header header
  uint32 height
  uint32 width
  sensor_msgs/PointField[] fields
  bool is_bigendian
  uint32 point_step
  uint32 row_step
  uint8[] data
  bool is_dense
#+END_EXAMPLE

***** 使用 rosbag play 时产生 warnning

#+BEGIN_EXAMPLE
  Warning: TF_OLD_DATA ignoring data from the past for frame
  microstrain_link at time 1.45181e+09 according to authority
  unknown_publisher
#+END_EXAMPLE

Q&A [[http://answers.ros.org/question/201948/tf_old_data-ignoring-data-from-the-past-for-frame-odom/][TF_OLD_DATA ignoring data from the past for frame odom]]


_The error messages suggest you're running with simulated time_. Make
sure that you've set the flag to make sure the whole system is using
simulated time by setting the parameter *use_sim_time* before you
start any nodes.

#+BEGIN_EXAMPLE
rosparam set use_sim_time true
#+END_EXAMPLE

***** 不用使用 laser_assembler 对进行可视化，更好的方式是修改 rviz 中 laser_scan 的 *Queue Size*

1. Queue Size 设置太大，会占用太多的内存，导致电脑卡
2. 配合设置 Color 和 Alpha 可视化效果简直棒极了
3. 不要实时地使用

*不是缓存 Queue size 而是 rosbag play --clock 选项*

***** laser_assembler 用来组合 scan 到 固定坐标系map 下

1. 可以配合 service call 实时地显示建模效果，但要合理地设置时间
2. 最好用来做一些后续的非实时的处理

***** PCL

1. [X] 保存 cloudpiont2 为 bag

   laser_assembler + service call

2. [X] 转换为 PCD

   #+BEGIN_EXAMPLE
     rosrun pcl_ros bag_to_pcd pointcloud2_0106.bag /assembled_pointcloud2 pcds/
   #+END_EXAMPLE

   data/pcds

3. [ ] 组合 PCD

   http://pointclouds.org/documentation/tutorials/concatenate_clouds.php

4. [X] 处理 PCD downsample

   #+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/src/voxel_grid.cpp

**** hector_mapping.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/hector_mapping.launch :src xml

**** Hector SLAM 的 Map/odom/base_footprint 的配置问题

***** 问题描述

1) odom 由谁发布？
2) map 与 odom 之间的关联

[[/home/ben/Wally/Journal//Figure/scrot/2959IZS.png]]

[[/home/ben/Wally/Journal//Figure/scrot/2959VjY.png]]

***** solution 1

http://wiki.ros.org/hector_slam/Tutorials/SettingUpForYourRobot

The system can also be used without broadcasting any tf
transformation. This can be useful if another node is responsible for
publishing the map->odom or map->base_frame transform.

In this case, the estimated pose published on the poseupdate topic of
hector_mapping might be used for example by a INS system which then
publishes a map->base_frame transform.


#+BEGIN_EXAMPLE
  <arg name="odom_frame" default="odom"/>
  <arg name="pub_map_odom_transform" default="true"/>
#+END_EXAMPLE

***** error

#+BEGIN_EXAMPLE
[ERROR] [1451717998.212424627, 25.216000000]: Transform failed during
publishing of map_odom transform: "odom" passed to lookupTransform
argument target_frame does not exist.

[ERROR] [1451717998.830369203, 25.762000000]: Transform failed during
publishing of map_odom transform: Lookup would require extrapolation
at time 24.721000000, but only time 24.637000000 is in the buffer,
when looking up transform from frame [base_footprint] to frame [odom]
#+END_EXAMPLE

不存在 odom ???


#+BEGIN_EXAMPLE
~ $ rosnode info /hector_mapping
--------------------------------------------------------------------------------
Node [/hector_mapping]
Publications:
 * /map_metadata [nav_msgs/MapMetaData]
 * /slam_cloud [sensor_msgs/PointCloud]
 * /rosout [rosgraph_msgs/Log]
 * /tf [tf2_msgs/TFMessage]
 * /poseupdate [geometry_msgs/PoseWithCovarianceStamped]
 * /map [nav_msgs/OccupancyGrid]
 * /slam_out_pose [geometry_msgs/PoseStamped]

Subscriptions:
 * /syscommand [unknown type]
 * /tf_static [unknown type]
 * /initialpose [unknown type]
 * /tf [tf2_msgs/TFMessage]
 * /lidar_scan [unknown type]

Services:
 * /hector_mapping/set_logger_level
 * /hector_mapping/get_loggers
 * /dynamic_map

#+END_EXAMPLE


也就是说不存在 Odom 坐标系

***** use_sim_time?

Tells ROS nodes asking for time to get the Gazebo-published simulation
time, published over the ROS topic /clock (default true)

#+BEGIN_EXAMPLE
Warning: TF_OLD_DATA ignoring data from the past for frame base_footprint at time 35.174 according to authority unknown_publisher
Possible reasons are listed at http://wiki.ros.org/tf/Errors%20explained
at line 260 in /tmp/buildd/ros-indigo-tf2-0.5.9-0trusty-20150326-1908/
#+END_EXAMPLE

***** 解决 通过 base_stablized 配置

[[/home/ben/Wally/Journal//Figure/scrot/2959AUv.png]]

***** 配合使用 plannar-move 有新的问题

**** gazbo world

- http://jderobot.org/Teaching_robotics_with_jderobot

**** robot_description setting for rosbag

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/robot_description.launch :src xml


**** usb_cam

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/launch/usb_cam.launch :src xml


format: *uyvy*

rate: 30, OK

io_method: mmap

pixel_format:
- mjpeg
  #+BEGIN_EXAMPLE
   Webcam: expected picture but didn't get it...
  #+END_EXAMPLE
- 之后再设置为 yuyv 正常了


使用 rviz 和 image_view 显示的都是偏 红和绿 ？？？

- contrast 不是

** Julie

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/README.md
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/ChangeLog.org

*** Thoughts on ROS
+ 不一定非要以源码方式安装package, *只有需要深入研究并借鉴的才使用源码
  安装* -> 精简
*** Problems
**** TODO 编译 gazebo_ros_package 失败
‘Q_WS_WIN’ was not declared in this scope

TODO 暂时不管
*** Stack: Julie
*** Metapackage                                               :metapackage:

[2015-11-24 周2 19:09]

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie/package.xml :src xml :lines "9-"

元包(Metapackage)是一种特殊的包，它不包含任何代码、文件或其它常见的条
目。它仅仅是简单的引用一个或几个相关松散耦合的包。

It is often convenient to group multiple packages as a single logical
package. This can be accomplished through metapackages. A metapackage
is a normal package with the following export tag in the package.xml:
*<metapackage />*

#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
 <export>
   <metapackage />
 </export>
\end{minted}
#+end_latex

Other than a required <buildtool_depends> dependency on catkin,
metapackages can only have run dependencies on packages of which they
group.

Additionally a metapackage has a required, boilerplate CMakeLists.txt
file: *catkin_metapackage()*

#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
cmake_minimum_required(VERSION 2.8.3)
project(<PACKAGE_NAME>)
find_package(catkin REQUIRED)
catkin_metapackage()
\end{minted}
#+end_latex
Note: replace <PACKAGE_NAME> with the name of the metapackage.

boilerplate: 样板，所谓样板，是指一尘不变，使用catkin_create_package命
令生成的CMakeLists.txt文件会有 *多余* 的配置，导致编译时失败。

/This workspace contains non-catkin packages in it, and catkin cannot build  a non-homogeneous workspace without isolation.  Try the 'catkin_make_isolated' command instead./

*** julie_bringup

*** julie_description
CLOCK: [2015-11-25 三 14:39]--[2015-11-25 三 14:49] =>  0:10

**** package management
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/package.xml :src xml
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/CMakeLists.txt :src cmake


***** 手记                                                       :catkin:
使用 catkin_create_pkgs 命令生成的 package 配置文件中除基本信息外，添
加了以下信息

1. package.xml 中的 *find_package()*
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{cmake}
       find_package(catkin REQUIRED COMPONENTS
         tf
         urdf
       )
     \end{minted}
   #+end_latex
2. CMakeLists.txt 中的 *<build_depend>* 和 *<run_depend>*
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
     <build_depend>urdf</build_depend>
     <run_depend>urdf</run_depend>
     \end{minted}
   #+end_latex


#+BEGIN_EXAMPLE
  tmp $ catkin_create_pkg test urdf tf
  Created file test/package.xml
  Created file test/CMakeLists.txt
  Successfully created files in /tmp/test. Please adjust the values in package.xml.
  tmp $ ls test
  CMakeLists.txt  package.xml
  tmp $ cat test/CMakeLists.txt | grep urdf
    urdf
  #  CATKIN_DEPENDS tf urdf
  tmp $ cat test/package.xml | grep urdf
    <build_depend>urdf</build_depend>
    <run_depend>urdf</run_depend>

#+END_EXAMPLE

**** urdf

#+BEGIN_SRC sh :results output :exports both
ls -l ~/Wally/Project/catkin_ws/src/julie/julie_description
#+END_SRC

#+RESULTS:
: 总用量 24
: -rw-rw-r-- 1 ben ben  111 11月 25 14:34 CMakeLists.txt
: drwxrwxr-x 2 ben ben 4096 11月 27 16:44 launch
: drwxrwxr-x 2 ben ben 4096 11月 27 16:46 meshes
: -rw-rw-r-- 1 ben ben  435 11月 25 14:20 package.xml
: drwxrwxr-x 2 ben ben 4096 11月 26 19:59 test
: drwxrwxr-x 2 ben ben 4096 11月 26 22:41 urdf

***** emacs auto-mode-alist
#+begin_latex
\begin{minted}[frame=single, mathescape]{lisp}
(add-to-list 'auto-mode-alist '("\\.xacro\\'" . nxml-mode))
(add-to-list 'auto-mode-alist '("\\.urdf\\'" . nxml-mode))
\end{minted}
#+end_latex

***** common_properties.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/common_properties.xacro :src xml


***** hokuyo.xacro
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/hokuyo.xacro :src xml


****** Trick 增加test文件夹用于测试，内部文件使用链接形式        :trick:

****** test
*$ rosrun xacro xacro.py test/hokuyo.xacro alpha:=true -o hokuyo.urdf*

+ 传递命令行参数
+ -o 指定输出文件名

*$ check_urdf hokuyo.urdf*

#+BEGIN_EXAMPLE
  robot name is: sensor_hokuyo
  ---------- Successfully Parsed XML ---------------
  root Link: base_link has 1 child(ren)
      child(1):  hokuyo_link_link
#+END_EXAMPLE

****** TODO 中文注释问题
UnicodeEncodeError: 'ascii' codec can't encode characters in position
464-471: ordinal not in range(128)

xacro.py 文件编码没有问题，

-> 那问题就是 *XML编码* ？

好的推断，但不对！

Pyhont 中 file.write() 方法的编码问题， /暂时解决不了/

*XML文件要有必要的注释，所以暂时使用英文注释*



****** error
1. xacro.XacroException: Property wasn't defined: u'_parent'

   property 使用 property定义， arg传递的是命令行参量(xacro.py)。

2. xacro.XacroException: Property parent recursively used

   macro中使用的参数名称不能与已经定义的property相同

***** microstrain.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/microstrain.xacro :src xml

类似 hokuyo.acro

***** TODO julie.xacro

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/urdf/julie.xacro :src xml

#+BEGIN_EXAMPLE
  $ check_urdf julie.urdf
  robot name is: julie
  ---------- Successfully Parsed XML ---------------
  root Link: base_footprint has 1 child(ren)
      child(1):  base_link
          child(1):  imu_link
          child(2):  lidar_link
#+END_EXAMPLE

**** launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_description/launch/display.launch :src xml

*** julie_gazebo
**** note

*ROS Jade is using the gazebo-5.x series* Jade有更多的特性，可以尝试。

**** gazebo_world
***** empty_world.launch
****** launch
#+include: ~/Wally/Project/catkin_ws/src/julie/julie_gazebo/launch/empty_world.launch :src xml

#+BEGIN_EXAMPLE
  julie_gazebo $ roslaunch gazebo_ros
  empty_world.launch         shapes_world.launch
  mud_world.launch           willowgarage_world.launch
  rubble_world.launch
#+END_EXAMPLE

****** gazebo_ros args
******* gzserver 命令行选项
*$ gzserver --help*

#+BEGIN_EXAMPLE
gzserver -- Run the Gazebo server.

`gzserver` [options] <world_file>

Gazebo server runs simulation and handles commandline options, starts
a Master, runs World update and sensor generation loops.


Options:
  -q [ --quiet ]                Reduce output to stdout.
  -h [ --help ]                 Produce this help message.
  -u [ --pause ]                Start the server in a paused state.
  -e [ --physics ] arg          Specify a physics engine
                                (ode|bullet|dart|simbody).
  -p [ --play ] arg             Play a log file.
  -r [ --record ]               Record state data.
  --record_encoding arg (=zlib) Compression encoding format for log data
                                (zlib|bz2|txt).
  --record_path arg             Absolute path in which to store state data
  --seed arg                    Start with a given random number seed.
  --iters arg                   Number of iterations to simulate.
  --minimal_comms               Reduce the messages output by gzserver
  -s [ --server-plugin ] arg    Load a plugin.
#+END_EXAMPLE

******* gazebo_ros 结点

$ rosrun gazebo_ros

#+BEGIN_EXAMPLE
debug        gdbrun       gzserver     spawn_model
gazebo       gzclient     perf
#+END_EXAMPLE

******* empty_world.launch 命令行参数含义

1. gui: *gzclient*

   Launch the user interface window of Gazebo (default true)

2. paused: gzserve -u

   Start Gazebo in a paused state (default false)
   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg unless="$(arg paused)" name="command_arg1" value=""/>
       <arg     if="$(arg paused)" name="command_arg1" value="-u"/>
     \end{minted}
   #+end_latex

3. headless: gzserver -r

   Disable any function calls to simulator rendering (Ogre)
   components. Does not work with gui:=true (default false)

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg     if="$(arg headless)" name="command_arg2" value="-r"/>
       <arg unless="$(arg verbose)" name="command_arg3" value=""/>
     \end{minted}
   #+end_latex

4. debug: gzserver/debug

   Start gzserver (Gazebo Server) in debug mode using gdb (default
   false)

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg unless="$(arg debug)" name="script_type" value="gzserver"/>
       <arg     if="$(arg debug)" name="script_type" value="debug"/>
     \end{minted}
   #+end_latex

5. verbose: gzserve --verbose

   #+begin_latex
     \begin{minted}[frame=single, mathescape]{xml}
       <arg unless="$(arg verbose)" name="command_arg3" value=""/>
       <arg     if="$(arg verbose)" name="command_arg3" value="--verbose"/>
     \end{minted}
   #+end_latex

6. usesimtime(gazebo)

   Tells ROS nodes asking for time to get the Gazebo-published
   simulation time, published over the ROS topic /clock (default true)

7. respawn: roslaunch node arguments

8. output: roslaunch node arguments

****** $GAZEBO_RESOURCE_PATH
#+BEGIN_SRC sh :results output :exports both
echo $GAZEBO_RESOURCE_PATH
#+END_SRC

#+RESULTS:
:

+ ~/.gazebo
+ /usr/share/gazebo-2.2/

****** empty.world

#+INCLUDE: /usr/share/gazebo-2.2/worlds/empty.world

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_gazebo/worlds/empty.world

****** 小结

理清了通过gazebo_ros启动Gazebo的最基本的launch。

***** julie_world.launch
#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_gazebo/launch/julie_gazebo.launch :src xml

****** spawn_model arguments

~ $ *rosrun gazebo_ros spawn_model -h*

#+BEGIN_EXAMPLE
  spawn_model script started
  Commands:
      -[urdf|sdf|trimesh|gazebo] - specify incoming xml is urdf, sdf or trimesh format. gazebo arg is deprecated in ROS Hydro
      -[file|param|database] [<file_name>|<param_name>|<model_name>] - source of the model xml or the trimesh file
      -model <model_name> - name of the model to be spawned.
      -reference_frame <entity_name> - optinal: name of the model/body where initial pose is defined.
                                       If left empty or specified as "world", gazebo world frame is used.
      -gazebo_namespace <gazebo ros_namespace> - optional: ROS namespace of gazebo offered ROS interfaces.  Defaults to /gazebo/ (e.g. /gazebo/spawn_model).
      -robot_namespace <robot ros_namespace> - optional: change ROS namespace of gazebo-plugins.
      -unpause - optional: !!!Experimental!!! unpause physics after spawning model
      -wait - optional: !!!Experimental!!! wait for model to exist
      -trimesh_mass <mass in kg> - required if -trimesh is used: linear mass
      -trimesh_ixx <moment of inertia in kg*m^2> - required if -trimesh is used: moment of inertia about x-axis
      -trimesh_iyy <moment of inertia in kg*m^2> - required if -trimesh is used: moment of inertia about y-axis
      -trimesh_izz <moment of inertia in kg*m^2> - required if -trimesh is used: moment of inertia about z-axis
      -trimesh_gravity <bool> - required if -trimesh is used: gravity turned on for this trimesh model
      -trimesh_material <material name as a string> - required if -trimesh is used: E.g. Gazebo/Blue
      -trimesh_name <link name as a string> - required if -trimesh is used: name of the link containing the trimesh
      -x <x in meters> - optional: initial pose, use 0 if left out
      -y <y in meters> - optional: initial pose, use 0 if left out
      -z <z in meters> - optional: initial pose, use 0 if left out
      -R <roll in radians> - optional: initial pose, use 0 if left out
      -P <pitch in radians> - optional: initial pose, use 0 if left out
      -Y <yaw in radians> - optional: initial pose, use 0 if left out
      -J <joint_name joint_position> - optional: initialize the specified joint at the specified value
#+END_EXAMPLE

****** $() ${} *不要混淆*

error: ${alpha} is not a 'bool' type

在 launch 文件中， 使用 $() <dollor圆括号> 替换， 仅此一个

在 xacro 文件中， 使用 ${} <dollor花括号> 进行引用属性或者数学运算，使
用 $() 进行命令行参数传递。

****** 文件与文件夹命名要有规范

#+BEGIN_EXAMPLE
  Error [SystemPaths.cc:367] File or path does not exist
  ["/home/ben/Wally/Project/catkin_ws/src/julie/julie_gazebo/world/empty.world"]
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  $ ls ~/.gazebo/ | grep world
  worlds
#+END_EXAMPLE

****** 手记
******* test as a whole: ok

#+BEGIN_EXAMPLE
$ roslaunch julie_gazebo julie_gazebo.launch
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  test $ rosnode list
  /gazebo
  /rosout
  test $ rostopic list
  /clock
  /cmd_vel
  /gazebo/link_states
  /gazebo/model_states
  /gazebo/parameter_descriptions
  /gazebo/parameter_updates
  /gazebo/set_link_state
  /gazebo/set_model_state
  /imu_data
  /lidar_scan
  /odom
  /rosout
  /rosout_agg
  /tf
#+END_EXAMPLE

******* test lidar/imu
******** $() 不允许嵌套

#+begin_latex
\begin{minted}[frame=single, mathescape]{xml}
<param     if="$(arg alpha)" name="robot_description" command="$(arg $(arg sensor}_model)" />
\end{minted}
#+end_latex
error:

*Dollar signs '$' cannot be inside of substitution args [$(arg $(arg
sensor}_model)]*

******** 修改： 组合使用 if/unless/group 实现多重条件

#+begin_latex
  \begin{minted}[frame=single, mathescape]{xml}
    <param unless="$(arg alpha)" name="robot_description" command="$(arg robot_model)" />
    <group     if="$(arg alpha)">
    <param unless="$(arg test)" name="robot_description" command="$(arg imu_model)" />
    <param     if="$(arg test)" name="robot_description" command="$(arg lidar_model)" />
    </group>
  \end{minted}
#+end_latex

******** lidar： ok

#+BEGIN_EXAMPLE
$ roslaunch julie_gazebo julie_gazebo.launch alpha:=true
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  test $ rosnode list
  /gazebo
  /rosout
  test $ rostopic list
  /clock
  /gazebo/link_states
  /gazebo/model_states
  /gazebo/parameter_descriptions
  /gazebo/parameter_updates
  /gazebo/set_link_state
  /gazebo/set_model_state
  /hokuyo_scan
  /rosout
  /rosout_agg
  test $
#+END_EXAMPLE

******** imu: ok,  test参数取名不好

#+BEGIN_EXAMPLE
test $ roslaunch julie_gazebo julie_gazebo.launch alpha:=true test:=false
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  test $ rostopic list
  /clock
  /gazebo/link_states
  /gazebo/model_states
  /gazebo/parameter_descriptions
  /gazebo/parameter_updates
  /gazebo/set_link_state
  /gazebo/set_model_state
  /imu_data
  /rosout
  /rosout_agg
#+END_EXAMPLE

**** gazebo_rviz: 尽量地减少不同模块的耦合

*** julie_launch

julie_launch 主要包含了一些launch文件，主要以下配置文件

|-------------------------+----------------------------+-------------|
| Sensors                 | package                    | node        |
|-------------------------+----------------------------+-------------|
| hokuyo UTM30(Lidar)     | hokuyo_node                | hokuyo_node |
| microstrain 3GMS25(IMU) | microstrain_3dmgx2_imuNode | imu_node    |
|-------------------------+----------------------------+-------------|

#+include: ~/Wally/Project/catkin_ws/src/julie/julie_launch/CMakeLists.txt

#+include: ~/Wally/Project/catkin_ws/src/julie/julie_launch/CMakeLists.txt

**** hokuyo.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hokuyo.launch :src xml

1. hokuyo connecting
2. hokuyo parameters setting
3. roslaunch if/unless

测试OK。

**** microstrain.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/microstrain.launch :src xml

IMU 有个初始化的过程，需要几秒钟的时间。

***** TODO 姿态似乎并不是很准 why?

1. 传感器输出的是什么数据？
2. ROS用的是什么消息，定义的是什么内容？
3. 如果需要校正，如何处理？

#+BEGIN_EXAMPLE
  header:
    seq: 1956
    stamp:
      secs: 1448536768
      nsecs: 743254578
    frame_id: imu_link
  orientation:
    x: 0.998275596255
    y: -0.0579387949886
    z: -0.00247682392276
    w: 0.00910004910749
  orientation_covariance: [0.0012250000000000002, 0.0, 0.0, 0.0, 0.0012250000000000002, 0.0, 0.0, 0.0, 0.0012250000000000002]
  angular_velocity:
    x: -0.000441648298874
    y: 0.000969532527961
    z: 0.00244149100035
  angular_velocity_covariance: [0.000144, 0.0, 0.0, 0.0, 0.000144, 0.0, 0.0, 0.0, 0.000144]
  linear_acceleration:
    x: -0.049793684483
    y: 0.180994773722
    z: -9.81023545727
  linear_acceleration_covariance: [0.009604000000000001, 0.0, 0.0, 0.0, 0.009604000000000001, 0.0, 0.0, 0.0, 0.009604000000000001]
#+END_EXAMPLE

**** lidar_sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/lidar_sim.launch :src xml

**** imu_sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/imu_sim.launch :src xml

OK， 证明 rviz.launch 可行

**** rviz.launch

仅可视化激光数据，用于测试传感器或仿真，一般需要被其他launch文件包含。

1. 匿名rviz
2. config arg

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/rviz.launch :src xml

**** hector slam

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hector.launch :src xml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hector_with_imu.launch :src xml

1. /map_size/ 的大小会影响实时性，所以不能太大
2. hector_imu_attitude_to_tf 的 /API/ 消息和参数的命名和 /remap/
   [[file:~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/hector_with_imu.launch::<node%20pkg%3D"hector_imu_attitude_to_tf"%20type%3D"imu_attitude_to_tf_node"%20name%3D"imu_attitude_to_tf_node"%20][hector_imu_attitude_to_tf]]

**** map merge

http://answers.ros.org/question/133486/how-can-i-merge-some-maps/

https://github.com/tu-darmstadt-ros-pkg/mapstitch

**** julie.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/julie.launch :src xml

**** sim.launch

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/sim.launch :src xml

[[~/Wally/Journal/Figure/scrot/30792uVs.png]]

**** teleop_key.py

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/scripts/teleop_key.py :src python

发送命令 /cmd_vel 给 plannar_move_plugin

最好在单独一个窗口，因为需要交互。

***** sys, select, termios, tty
#+begin_latex
\begin{minted}[frame=left, mathescape]{py}
import sys, select, termios, tty
\end{minted}
#+end_latex

*优先查阅手册*

****** termios:Low-level terminal control interface.           :termios:

This module provides an interface to the POSIX calls for tty I/O
control.

All functions in this module take a *file descriptor fd* as their first
argument. This can be an integer file descriptor, such as returned by
*sys.stdin.fileno()*, or a file object, such as *sys.stdin* itself.

[[/home/ben/Wally/Journal/Figure/scrot/4904FSb.png]]

******* example
#+INCLUDE: ~/Wally/Journal/Project/Python/termios/test.py :src python

输入密码时不可见

****** tty:Terminal control functions                              :tty:

The *tty* module defines functions for putting the tty into cbreak and
raw modes.

1. what is tty?
2. what is cbreak mode?
3. what is raw mode?

+Because it requires the termios module, it will work only on Unix+

[[/home/ben/Wally/Journal/Figure/scrot/4904TrQ.png]]

****** 终端模式                                                   :term:

终端I/O有两种不同的工作方式：
1. 规范方式输入处理。在这种方式中，终端输入以行为单位进行处理。对于每
   个读要求，终端驱动程序最多返回一行。
2. 非规范方式输入处理。输入字符不以行为单位进行装配。

如果不作特殊处理，则默认方式是规范方式。

V7和BSD类的终端驱动程序支持三种终端输入方式：
+ 精细加工方式(输入装配成行，并对特殊字符进行处理)；
+ 原始方式(输入不装配成行，也不对特殊字符进行处理)；
+ cbreak方式(输入不装配成行，但对某些特殊字符进行处理)。

******* reference

+ [[https://app.yinxiang.com/shard/s52/nl/11551545/3300d5e1-d8a3-48df-8ff1-bc4be441f46d?title=%E7%BB%88%E7%AB%AFI%2FO%20termios%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%20tcsetattr%E8%AE%BE%E7%BD%AE%20-%20dartagnan%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD][CNDS: 终端I/O termios属性设置 tcsetattr]]
****** select: waiting for I/O completion                       :select:

This module provides access to the *select()* and *poll()* functions
available in most operating systems, epoll() available on Linux 2.5+
and kqueue() available on most BSD. Note that on Windows, it only
works for sockets; on other operating systems, it also works for other
file types (in particular, on Unix.

[[/home/ben/Wally/Journal/Figure/scrot/4904tNF.png]]

****** dict
#+begin_latex
  \begin{minted}[frame=left, mathescape]{py}
  moveBindings = {
          'i':(1,0),
          'o':(1,-1),
          'j':(0,1),
          'l':(0,-1),
          'u':(1,1),
          ',':(-1,0),
          '.':(-1,1),
          'm':(-1,-1),
             }

  speedBindings={
          'q':(1.1,1.1),
          'z':(.9,.9),
          'w':(1.1,1),
          'x':(.9,1),
          'e':(1,1.1),
          'c':(1,.9),
            }
  \end{minted}
#+end_latex

****** def get_key()

#+begin_latex
  \begin{minted}[frame=left, mathescape]{py}
  def getKey():
      tty.setraw(sys.stdin.fileno())
      rlist, _, _ = select.select([sys.stdin], [], [], 0.1)
      if rlist:
          key = sys.stdin.read(1)
      else:
          key = ''

      termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
      return key

  speed = 0.75
  turn = 1
  \end{minted}
#+end_latex

1. setraw 设置为原始模式

2. rlist: wait until ready for reading

****** ros related

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
      rospy.init_node('teleop')
      pub = rospy.Publisher('/cmd_vel', Twist, queue_size=5)

      ...

      twist = Twist()
      twist.linear.x = control_speed; twist.linear.y = 0; twist.linear.z = 0
      twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = control_turn
      pub.publish(twist)
  \end{minted}
#+end_latex

****** speed control logic
#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
          while(1):
              key = getKey()
              if key in moveBindings.keys():
                  x = moveBindings[key][0]
                  th = moveBindings[key][1]
                  count = 0
              elif key in speedBindings.keys():
                  speed = speed * speedBindings[key][0]
                  turn = turn * speedBindings[key][1]
                  count = 0

                  print vels(speed,turn)
                  if (status == 14):
                      print msg
                  status = (status + 1) % 15
              elif key == ' ' or key == 'k' :
                  x = 0
                  th = 0
                  control_speed = 0
                  control_turn = 0
              else:
                  count = count + 1
                  if count > 4:
                      x = 0
                      th = 0
                  if (key == '\x03'):
                      break

              target_speed = speed * x
              target_turn = turn * th

              if target_speed > control_speed:
                  control_speed = min( target_speed, control_speed + 0.02 )
              elif target_speed < control_speed:
                  control_speed = max( target_speed, control_speed - 0.02 )
              else:
                  control_speed = target_speed

              if target_turn > control_turn:
                  control_turn = min( target_turn, control_turn + 0.1 )
              elif target_turn < control_turn:
                  control_turn = max( target_turn, control_turn - 0.1 )
              else:
                  control_turn = target_turn

              twist = Twist()
              twist.linear.x = control_speed; twist.linear.y = 0; twist.linear.z = 0
              twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = control_turn
              pub.publish(twist)

  \end{minted}
#+end_latex

****** try

#+begin_latex
  \begin{minted}[frame=leftline, mathescape]{py}
    try:
        ...
    except:
        print e
   finally:
        twist = Twist()
        twist.linear.x = 0; twist.linear.y = 0; twist.linear.z = 0
        twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = 0
        pub.publish(twist)
  \end{minted}
#+end_latex

**** bagfile
#+INCLUDE: ~/Wally/Project/catkin_ws/bagfile/

**** rosbag 不是一个包，不能在 launch file中启动

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/bag.launch :src xml

**** DONE laser_filter.launch
- State "DONE"       from "NEXT"       [2015-12-23 三 19:49]
- State "NEXT"       from "NEXT"       [2015-12-23 三 11:04] \\
  曲线比较，订阅并重新发布 scan_filtered
- State "NEXT"       from "NEXT"       [2015-12-23 三 10:28] \\
  - 在 rqt.launch 包含 rviz.lanuch 以及 toggle 参数
  - 更改 scan_filtered 的 frame_id 并 publish static tf from old frame
- State "NEXT"       from "TODO"       [2015-12-23 三 09:53] \\
  同样的配置重新测试可以了，下一步如何动态设置消息的 frame_id，可可视化
  需要
- State "TODO"       from ""           [2015-12-15 二 16:51] \\
  laser_filters 能够运行，接收和发布的话题配置也正确，只是发布的话题为空，
  不知为何

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/laser_filter.launch :src xml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/config/laser_filter.yaml :src yaml

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/scripts/reassign_frame_id.py

- laser_filters 前后 LaserScan 的 frame_id 一致
- laser_filters 的 Node API 中没有 frame_id 选项，也就是说，不能重置 frame_id

**** DONE rqt_launch
- State "DONE"       from ""           [2015-12-21 一 15:56] \\
  在理解了命令行方式之后，使用图形界面方式能够进一步增加开发效率

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/launch/rqt.launch

- perspective import export 的含义,  导出的文件不能像 rviz 那样直接作
  为参数在命令行传递，需要手动导入。新建的 perspective 可以作为参数。
- rviz 不要集成在 rqt 中
- 使用 rqt_bag 需要手动 publish，默认不发布。

[[/home/ben/Wally/Journal//Figure/scrot/29439HuT.png]]

**** NEXT tf_height.cpp
- State "NEXT"       from ""           [2016-01-02 六 16:55] \\
  1. 通过命令行传递高度参数
  2. 通过话题接收超声波传感器数据

The base_footprint frame provides no height information and represents
the 2D pose of the robot (position and orientation). The
base_stabilized frame adds information about the robot height relative
to the map/odom layer.

#+INCLUDE: ~/Wally/Project/catkin_ws/src/julie/julie_launch/src/tf_height.cpp

*** MultiMachine 连接 raspberry

1. ROS_MASTER_URI

   #+BEGIN_EXAMPLE
   ~ $ export ROS_MASTER_URI=http://192.168.1.3:11311
   #+END_EXAMPLE

2. ROS_IP

   error: /Couldn't find an AF_INET address for .../

   + http://answers.ros.org/question/163556/how-to-solve-couldnt-find-an-af_inet-address-for-problem/

   #+BEGIN_EXAMPLE
   export ROS_IP=10.0.6.9
   #+END_EXAMPLE

   192.168.1.4

   #+BEGIN_EXAMPLE
   $ hostname -I
   #+END_EXAMPLE

   just set on every computer in you network (so you don't have to
   thing about addresses):

   #+BEGIN_EXAMPLE
   export ROS_IP=`hostname -I`
   #+END_EXAMPLE

   Or even, sometimes better, solution is to add this line in your
   .bashrc file.

3. +测试可以，但是延迟似乎过高，是否有影响还有待测试+

   原因可能有
   - raspberry 不够快，查看内在试试
   - wlan 和 eth0 之间通信并不快？？？

** NEXT Simulation(tager)
:LOGBOOK:
- State "NEXT"       from ""           [2016-03-08 二 16:26] \\
  1. 选择好了名称前缀 tager
  2. 利用 kobuki 的模型文件建立了 urdf 文件

  下一步在 Gazebo 中添加差分驱动 plugin 并实现运动控制及数据采集
:END:
*** overview

- Python
- Gazebo / ROS / RVIZ
- Line Extraction
- Differental drivers
- EKF
- IMU
- C++
- EKF-SLAM
- 算法复杂度

*** model

*** gazebo diff driver

http://answers.ros.org/question/68599/using-diff-drive-to-drive-a-new-robot/

*** camon



**** Notes

1. 从目录组织结构到编码风格全面参考 PR2
2. 机械结构上参考实验室的小车
3. 不要引用 wally 和 julie 里的文件

**** TODOs

- [ ] 前轮差分
- [ ] 后轮为全向轮
- [ ] 水平方向的静态 SICK 和舵机控制做俯仰旋转的 SICK
- [ ] 普通相机
- [ ] Kinect
- [ ] 使用 blender 绘制需要的三维网格模型

**** camon description

#+include: ~/Wally/Project/catkin_ws/src/camon/camon_description/CMakeLists.txt
#+include: ~/Wally/Project/catkin_ws/src/camon/camon_description/package.xml

Notes
1. 不要包含 launch 文件

***** catkin_create_pack error

#+BEGIN_EXAMPLE
catkin_create_pkg: error: argument --rosdistro is required
$ catkin_create_pkg camon_description  --rosdistro jade
#+END_EXAMPLE

***** 目录结构参照 pr2_description

- documents: 包含文档，可以使用 doc 作为目录名
- gazebo: gazebo 仿真相关
- materials: 材质图片文件
- meshes: 包含三维风格文件(.dae)
- robots: 以不同方式组合机器人
- test: 测试文件
- urdf: 部件的 xacro 文件

***** urdf

#+include: ~/Wally/Project/catkin_ws/src/camon/camon_description/urdf/common.xacro
#+include: ~/Wally/Project/catkin_ws/src/camon/camon_description/urdf/materials.xacro

****** base

#+include: ~/Wally/Project/catkin_ws/src/camon/camon_description/urdf/base/base.usdf.xacro

****** sensors

****** tilting laser

**** camon launch

#+include: ~/Wally/Project/catkin_ws/src/camon/camon_launch/CMakeLists.txt
#+include: ~/Wally/Project/catkin_ws/src/camon/camon_launch/package.xml

仅包含一些 launch 文件

***** display.launch

#+include: ~/Wally/Project/catkin_ws/src/camon/camon_launch/launch/display.launch

****** 测试 pr2 base

** NEXT CAMON
:LOGBOOK:
- State "NEXT"       from "NEXT"       [2016-03-10 四 15:48] \\
  测试 IMU 和 Lidar，通过多机实验
- State "NEXT"       from "NEXT"       [2016-03-10 四 15:23] \\
  测试 microstrain launch
- State "NEXT"       from "NEXT"       [2016-03-10 四 14:44] \\
  解决了git问题
- State "NEXT"       from "NEXT"       [2016-03-09 三 17:36] \\
  尝试搭建 git 服务器失败
- State "NEXT"       from ""           [2016-03-09 三 14:31] \\
  不要拖延，接线这部分准备完毕，便开始做 ROS 方面的工作
:END:
:README:
Camon is a stack containing my graduation project.

1. what's Camon?

   Camon(ChAndler MONica) comes from the names of my favorite roles in
   Friends.

2.
:END:
:CHANGELOG:
- 2016/03/09  将毕设相关的内容整理过来
:END:

#+include: ~/Wally/Project/catkin_ws/src/camon/

*** PCB
**** 电源模块
***** thoughts
+ 需要几种电源
+ 几层PCB，哪层做为电源层，怎么敷铜
+ 电源的反向防护（二级管选型）和过压保护（how）
***** 功率分析

- UTM

  [[/home/wally/Wally/Journal//Figure/scrot/151903Kb.png]]

- Microstrain

  [[/home/wally/Wally/Journal//Figure/scrot/15190EVh.png]]

- raspberry

  5V 1.2A
  - GPIO ： 50mA
  - HDMI : 50mA
  - Camera: 250mA
  - keyboard/mice: 100mA~1000mA

- LMS 291

  [[/home/ben/Wally/Journal//Figure/scrot/15190Rfn.png]]

Power

12*3 + 5*0.08 < 40W

https://e2e.ti.com/blogs_/b/powerhouse/archive/2015/09/16/high-density-pcb-layout-of-dc-dc-converters-part-2

***** 元器件选型


1. 保护二极管

   输入电压 24V，输入电流 5A -> *>=10A*

2. 电容

   1) C1 : 1000nF(1uF)/100v 1210 贴片

      [[https://detail.tmall.com/item.htm?spm=a1z10.3-b.w4011-9803707049.141.Qsl3xb&id=40172420253&rn=f07375e692f9f510e7f9f9688f5eb3e6&abbucket=2][TAOBAO]]

   2) C2 : 100nF(0.1uF)/100v 1206 贴片

      [[https://detail.tmall.com/item.htm?spm=a1z10.3-b.w4011-9803707049.31.qmjSjk&id=36669885421&rn=26301a86ca014ad46fb999cfea582e6d&abbucket=2][TAOBAO]]

   3) C3 : 470uF/50v  Cap_R10 直插

      [[http://world.tmall.com/item/36665230696.htm?spm=a312a.7700824.w4011-9803707049.65.sOVZdw&id=36665230696&rn=55cef1f557a853d34adb753cf387b5d8&abbucket=2][TAOBAO]]

   4) C4 ： 0.022uF（22nF）/250V

      [[http://world.tmall.com/item/40335907016.htm?spm=a312a.7700824.w4011-9803707049.31.22PlV1&id=40335907016&rn=d4739ac8c57f57b722550c98c70d636a&abbucket=2][TAOBAO]]

   5) C5 ： 22nF/1000V 1210 高耐压表贴陶瓷电容

      [[http://world.tmall.com/item/36669083118.htm?spm=a312a.7700824.w4011-9803644906.31.WxgZz9&id=36669083118&rn=eca23e5e0af541c5a7a508f8126efc54&abbucket=2][TAOBAO]]

   6) C6 100u/A * 5A = 500u，12V -> *470u, 25V* (输入端为24V，电压过小)

   [[/home/wally/Wally/Journal/Figure/scrot/2311yEz.png]]

3. 端子

   1) 5557 为连接器，选错，不能焊接到电路板上

   2) 重选

****** connector

输入： KF128-2
输出：5557 https://item.taobao.com/item.htm?id=41139630227&ali_refid=a3_430582_1006:1104098595:N:%E6%8F%92%E6%8B%94%E5%BC%8F%E6%8E%A5%E7%BA%BF%E7%AB%AF%E5%AD%90:cd6bd631faf7c8d74c8748dd98c47073&ali_trackid=1_cd6bd631faf7c8d74c8748dd98c47073&spm=a230r.1.14.3.Ozxn0o#detail

****** protector

电容：100uF/A

[[/home/wally/Wally/Journal/Figure/scrot/3098085D.png]]

二极管：

开关电源？

****** ref

[[https://app.yinxiang.com/shard/s52/nl/11551545/273c7e8c-dacd-4f22-a004-bb30aec5d710/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D152408a07ab%3AS%3Df5af2039594c32603700a7a7b6d115dc][直插式电阻电容封装与尺寸图解]]

[[https://app.yinxiang.com/shard/s52/nl/11551545/96b290e4-eb4d-4148-b51a-72fa4469c77e/?csrfBusterToken=U%3Db04339%3AP%3D%2F%3AE%3D152408b2f28%3AS%3D9a57fbc29200b7dff1aed88c48aa5ab2][Protel中Cap,Cap2，Cap Pol的区别]]

***** knowledge

****** 纹波

纹波(ripple)是由于直流稳定电源的电压波动而造成的一种现象，因为直流稳定电源一般
是由交流电源经整流稳压等环节而形成的，这就不可避免地在直流稳定量中多少
带有一些交流成份，这种叠加在直流稳定量上的交流分量就称之为纹波。纹波的
成分较为复杂，它的形态一般为频率高于工频的类似正弦波的谐波，另一种则是
宽度很窄的脉冲波。

****** mil

英制单位，100mil = 2.54mm

****** 电容尺寸

***** wally.pcblib

****** NE100S18K

1. 尺寸：58mm * 22mm
2. 引脚直径： 1mm，1.5mm
3. 引脚间距（图）

   *不太好测量*

*****
**** ARM芯片

+ Cortex系列
+ 内含CAN控制器
+ 最好支持openocd

**** flash
+ NAND（安装Ubuntu和ROS所需要的容量）
+ NOR
**** CAN模块
+ 淘宝：http://item.taobao.com/item.htm?spm=a230r.1.14.1.1GNisu&id=39187810657&ns=1&abbucket=14#detail

**** 网口
***** socket
整合多个串口
***** 多机
台式机运行图形界面
ARM传输数据
笔记本做算法
**** 参考
***** pcDuino
+ http://learn.linksprite.com/pcduino/pcduino-3-circuit-diagram/
+ https://github.com/pcduino/pcDuino3C_carrierboard
***** 古月居 http://blog.csdn.net/hcx25909/article/details/8539587
***** OpenSource hardware
+ https://www.linux.com/news/embedded-mobile/mobile-linux/732197-top-10-open-source-linux-boards-under-200
+ http://www.omappedia.com/wiki/PandaBoard
+ http://www.pcworld.com/article/2046232/top-opensource-pcs.html
+ http://www.techhive.com/article/242863/new_89_opensource_hardware_runs_full_linux_os.html
+ https://en.wikipedia.org/wiki/List_of_open-source_hardware_projects
+ https://en.wikipedia.org/wiki/Open-source_hardware

**** supply

*** hardware & sensors

**** 系统基本信息
***** 内核 3.13

#+BEGIN_EXAMPLE
ll@ll-OEM:~$ uname -a
Linux ll-OEM 3.13.0-76-generic #120-Ubuntu SMP Mon Jan 18 15:58:41 UTC 2016 i686 i686 i686 GNU/Linux
#+END_EXAMPLE

***** 发行版本 : Ubuntu 14.04

#+BEGIN_EXAMPLE
ll@ll-OEM:~$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 14.04.3 LTS
Release:	14.04
Codename:	trusty
#+END_EXAMPLE

***** 用户名及密码

user: ll
passwd: 123456

***** 桌面管理器

*LXDE* : LXDE 显然是桌面环境中最轻量级的选择

不是 GNOME

[2016-03-02 三 21:32]
#+BEGIN_SRC org
很不友好，但占用内在少，这很重要。
我暂时不会安装这样的系统，所以不要重装系统
#+END_SRC

***** 硬件 ID

#+BEGIN_EXAMPLE
00:16:ea:5f:2a:3c
#+END_EXAMPLE

**** DONE 配置静态 IP 为 192.168.1.27
:LOGBOOK:
- State "DONE"       from "NEXT"       [2016-03-09 三 11:45] \\
  先不管是否能连接 Internet，能够远程登录就足够了
- State "NEXT"       from ""           [2016-03-02 三 22:00] \\
  还没有完全配置好
:END:

参照 http://www.cnblogs.com/keygle/archive/2013/04/27/3048273.html

=/etc/network/interfaces=

#+BEGIN_EXAMPLE
auto wlan0
iface wlan0 inet static
address 192.168.1.26
netmask 255.255.255.0
gateway 192.168.1.1
wpa-ssid A409
wpa-passphrase A409A409A409
wireless-channel 11
#+END_EXAMPLE

[2016-03-02 三 21:26]
#+BEGIN_SRC org
似乎管用，尝试重启，IP配置正确，但并不确定是否为巧合。
#+END_SRC

[2016-03-02 三 21:51]
#+BEGIN_SRC org
无线网络并不正确，以上配置存在问题
*上不了网，但确能 ssh 远程登录!!!*

可能说明部分正确。
#+END_SRC

#+BEGIN_EXAMPLE
auto wlan0
iface wlan0 inet static
address 192.168.0.26
netmask 255.255.255.0
gateway 192.168.1.1
#+END_EXAMPLE

[2016-03-04 五 11:29]
#+BEGIN_SRC org
这样配置则在启动时 waiting for network configuration
启动后也 Ping 不上
#+END_SRC


#+BEGIN_EXAMPLE
auto wlan0
iface wlan0 inet static
address 192.168.1.27
gateway 192.168.1.1
netmask 255.255.255.0
broadcast 192.168.1.255
wpa-ssid "A409"
wpa-passphrase "A409A409A409"
#+END_EXAMPLE

[2016-03-09 三 11:44]
#+BEGIN_SRC org
这样配置 OK，修改静态的 IP 设置成功
将 IP 设置为 192.168.1.27
#+END_SRC

***** TODO service failed ?

#+BEGIN_EXAMPLE
ll@ll-OEM:~$ sudo service networking restart
stop: Job failed while stopping
start: Job is already running: networking
#+END_EXAMPLE

**** ssh 远程登录

#+BEGIN_EXAMPLE
wally@ ~ $ ssh ll@192.168.1.27
#+END_EXAMPLE

**** 安装 ROS

http://wiki.ros.org/indigo/Installation/Ubuntu

最小化安装

#+BEGIN_EXAMPLE
ROS-Base: (Bare Bones) ROS package, build, and communication libraries. No GUI tools.
sudo apt-get install ros-indigo-ros-base
#+END_EXAMPLE

ROS version

#+BEGIN_EXAMPLE
PARAMETERS
 * /rosdistro: indigo
 * /rosversion: 1.11.16
#+END_EXAMPLE

**** 测试 Hokuyo

***** USB 接口

****** installation

安装 ros-indigo-hokuyo-node

*error*

#+BEGIN_EXAMPLE
错误 http://packages.ros.org/ros/ubuntu/ trusty/main ros-indigo-diagnostic-updater i386 1.8.8-0trusty-20160110-094804-0800
无法解析域名“packages.ros.org”
#+END_EXAMPLE

原因： 网络没有配置好。

[2016-03-02 三 22:00]
#+BEGIN_SRC org
找到原因并安装完成
#+END_SRC

****** test

1. 连接 OK

   #+BEGIN_EXAMPLE
     ll@ll-OEM:~$ ls -l /dev/ttyACM0
     crw-rw---- 1 root dialout 166, 0  3月  2 22:02 /dev/ttyACM0
     ll@ll-OEM:~$ sudo chmod a+rw /dev/ttyACM0
     ll@ll-OEM:~$ ls -l /dev/ttyACM0
     crw-rw-rw- 1 root dialout 166, 0  3月  2 22:02 /dev/ttyACM0
   #+END_EXAMPLE

2. 运行 node, OK

   #+BEGIN_EXAMPLE
     ll@ll-OEM:~$ rostopic echo -n 1 /scan
     header:
       seq: 2175
       stamp:
         secs: 1456927581
         nsecs: 502319750
       frame_id: laser
     angle_min: -1.57079637051
     angle_max: 1.56643295288
     angle_increment: 0.00436332309619
     time_increment: 1.73611115315e-05
     scan_time: 0.0250000003725
     range_min: 0.0230000000447
     range_max: 60.0
     ranges: [0.11500000208616257, 0.11500000208616257, 0.11500000208616257,
   #+END_EXAMPLE

**** DONE 测试卡片电脑连接 IMU
:LOGBOOK:
- State "DONE"       from "NEXT"       [2016-03-04 五 15:51]
- State "NEXT"       from ""           [2016-03-04 五 10:13] \\
  阅读手册，直接通过串口连接 IMU
CLOCK: [2016-03-04 五 09:40]--[2016-03-04 五 10:13] =>  0:33
:END:

1. 安装 ros-indigo-microstrain-3dmgx2-imu OK

2. 测试连接

   1) 卡片电脑，无 /dev/ttyUSB0
   2) 台式机，有 /dev/ttyUSB0, 说明 IMU 连线不存在问题, ROS 节点读取数
      据亦OK
   3) 使用 usb-serial 转接
      - 驱动预安装，OK
        #+BEGIN_EXAMPLE
        Bus 002 Device 002: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapter
        #+END_EXAMPLE
      - 连接 IMU，读出 /dev/ttyUSB0 !!!
   4) OK

3. 测试 ROS 节点，OK

   - IMU 初始化大约需要 20s

4. 关闭节点以及 Ros master 后，IMU 显示依然在读取数据？？

   - 原因是切换到后台后 使用 kill 关闭，可能导致不完全
   - 在前台关闭则没有出现类似情况
   - 切换到前台关闭也 OK

5. 通过串口直接连接IMU

   查看串口设备
   #+BEGIN_EXAMPLE
   dmesg | grep ttyS*
   #+END_EXAMPLE

   经测为 ttyS1

   通过远程连接有如下 warning

   #+BEGIN_EXAMPLE
     [ WARN] [1457077522.141754754]: Exception thrown while trying to get the IMU reading. This sometimes happens due to a communication glitch, or if another process is trying to access the IMU port. You may try 'lsof|grep /dev/ttyS1' to see if other processes have the port open. invalid checksum.
     Make sure the IMU sensor is connected to this computer. (in microstrain_3dmgx2_imu::IMU:receive)
   #+END_EXAMPLE

**** NEXT ttyUSB 是什么？以及 IMU 手册阅读
:LOGBOOK:
- State "NEXT"       from "TODO"       [2016-03-04 五 10:50] \\
  没有搞明白
CLOCK: [2016-03-04 五 10:24]--[2016-03-04 五 10:50] =>  0:26
:END:

***** tty

****** [[https://www.rfc1149.net/blog/2013/03/05/what-is-the-difference-between-devttyusbx-and-devttyacmx/][What is the difference between /dev/ttyUSB and /dev/ttyACM?]]

Have you ever wondered why some USB devices used =/dev/ttyUSB0= (or 1,
or /n/) and others=/dev/ttyACM0= (or 1, or /n/) when they are plugged
into the host computer, while they seem to be acting as
[[https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter][UART]]
devices ([[https://en.wikipedia.org/wiki/RS-232][RS-232]]-like) over USB
in both cases? Have you wondered why example USB firmwares for
microcontrollers always end up with names such as =/dev/ttyACM0= and
never as =/dev/ttyUSB0=?

/Warning: this is a Linux specific post, although it also contains
genuine pieces of USB culture./

******* What does =ttyACM= mean?

The [[http://www.usb.org/][USB implementors forum]] organization has
described how devices conforming to the
[[https://en.wikipedia.org/wiki/USB_communications_device_class][Communications
Device Class (CDC)]] should present themselves to the USB host. The USB
implementors forum also specified how CDC subclasses should act,
including for those devices intended to talk with each other over the
[[https://en.wikipedia.org/wiki/Public_switched_telephone_network][public
switched telephone network (PSTN)]]. Those are known as
[[https://en.wikipedia.org/wiki/Modem][modems]] because the data goes
through a modulation operation on the sending side, which transforms the
bits into analog signals that can be carried over phone wires, and then
through a demodulation operation on the receiving side to convert the
analog signal back into the original bits.

To discuss with the modem, the host USB driver must use one of the
existing control models. For example, the /direct line control model/
controls how data is exchanged between the host and the modem through an
audio class interface, with the host taking charge of the modulation,
demodulation, data compression (such as V.42bis) and error correction
(such as V.42). This model is used by some
[[https://en.wikipedia.org/wiki/Softmodem][USB soft modems]], which are
very cheap because they mostly contain a
[[https://en.wikipedia.org/wiki/Digital_Signal_Processing][DSP]] chip
and some amplification and line adaptation layers.

Another control model, aptly named */abstract control model/* or ACM, lets
the modem hardware perform the analog functions, and require that it
supports the
[[https://en.wikibooks.org/wiki/Serial_Programming/Modems_and_AT_Commands][ITU
V.250]] (also known as Hayes in its former life) command set, either in
the data stream or as a separate control stream through the
communication class interface. When the commands are multiplexed with
the data in the data stream, an
[[https://en.wikipedia.org/wiki/Time_Independent_Escape_Sequence][escape
sequence]] such as Hayes 302 (also known as “1 sec +++ 1 sec”) or TIES
(that nobody remembers) must allow the host to put the modem into
command mode.

When developping on a USB-enabled embedded microcontroller that needs to
exchange data with a computer over USB, it is tempting to use a
standardized way of communication which is well supported by virtually
every operating system. This is why most people choose to implement
CDC/PSTN with ACM (did you notice that the Linux kernel driver for
=/dev/ttyACM0= is named =cdc_acm=?) because it is the simplest way to
exchange raw data.

But what about the mandatory V.250 command set? It is almost never
implemented in such devices, but since the host has no reason to
spontaneously generate V.250 commands by itself, the device will never
have to answer them. Pretending the embedded device is a modem is the
simplest way to communicate with it, even though it will probably never
perform any modulation or demodulation task. Linux will not know that
the device is lying, and will have it show up as =/dev/ttyS0=.

******* What does =ttyUSB= mean?

Sometimes, the embedded microcontroller does not come with a hardware
USB interface. While it is possible to use a
[[http://www.obdev.at/products/vusb/index.html][software-only USB
stack]], the additional constraints put onto the CPU and the usually
small storage size often lead board designers to include a dedicated
UART to USB bridge. Several vendors, such as
[[http://www.ftdichip.com/][FTDI]] or
[[http://www.prolific.com.tw/US/][Prolific]] sell dedicated chips for a
few euros.

Those vendors opted not to lie to the host computer in having the chips
announce themselves as USB modems when they were not. Each vendor
defined its own (usually proprietary) protocols, with commands allowing
to control functions of the chips such as setting the baud rate or
controlling additional signals used to implement
[[https://en.wikipedia.org/wiki/Flow_control_(data)#Hardware_flow_control][hardware
flow control]].

When it is practical to do so, Linux groups devices with similar
functionalities under the same default device or interface names. For
example, the UARTs present on your computer (if any) will be named
=/dev/ttyS0= and =/dev/ttyS1= even if one of them is a legacy
[[https://en.wikipedia.org/wiki/16550_UART][16550]] chip and the other
one is a
[[http://www.maximintegrated.com/datasheet/index.mvp/id/1731][MAX3100]]
[[https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus][SPI]]-controlled
UART. Similarly, the devices offering UART-over-USB functionalities are
named =/dev/ttyUSB0=, =/dev/ttyUSB1=, and so on, even though they are in
fact using distinct device drivers.

******* Conclusion

So, when you see a =/dev/ttyACM0= popping up, you can try to send it the
escape sequence followed by AT commands, but there is a good chance that
the device only pretends to be a modem and will happily send those
characters to the core application without even considering intercepting
them. If it is a =/dev/ttyS0=, do not try, unless the device behind the
USB-UART bridge understands those command by itself (this is the case
for the
[[http://www.digi.com/products/wireless-wired-embedded-solutions/zigbee-rf-modules/point-multipoint-rfmodules/xbee-series1-module][XBee]]
chip).

**** TCB UTM30LX-EW 连接测试
:LOGBOOK:
- State "TCB"        from "NEXT"       [2016-03-04 五 14:50] \\
  下一步通过文件自动配置网络，而不是使用GUI手动配置
- State "NEXT"       from ""           [2016-03-04 五 11:50] \\
  暂时没有成功
CLOCK: [2016-03-04 五 11:03]--[2016-03-04 五 11:49] =>  0:46
:END:

http://answers.ros.org/question/212527/hokuyo-utm-30lx-ew-laser-scanner-problems-to-detect/

卡片电脑未关闭系统直接断电(误操作)后，再上电，电脑直接启动，未短路触发。

1. 安装 urg_node, OK
2. ping not ok
3. IP 配置


*配置的是 eth0 的 IP，掩码和路由，与 wlan0 无关（独立）*

- IP: 192.168.0.15
- Mask: 255.255.255.0
- GateWay： 192.168.0.1

通过GUI配置有线网络连接 OK

***** [[http://wiki.ros.org/urg_node][urg_node]]               :urg_node:

****** Package Summary

Released No API documentation

urg_node

-  Maintainer status: maintained
-  Maintainer: Chad Rockey <chadrockey AT gmail DOT com>
-  Author: Chad Rockey <chadrockey AT gmail DOT com>
-  License: BSD

******* Supported Hardware

This driver should work with any SCIP 2.2 or earlier compliant laser
range-finders.

******* API Stability

The ROS API of this driver should be considered stable.

******* Parameter Ranges

The UTM-30LX laser can report corrupt data and even crash if settings
with an excessive data rate are requested. The following settings are
known to work:

*Intensity mode off*:

-  =cluster=: 1
-  =skip=: 1
-  =intensity=: false
-  =min_ang=: -2.2689
-  =max_ang=: 2.2689

*Intensity mode on*:

-  =cluster=: 1
-  =skip=: 1
-  =intensity=: true
-  =min_ang=: -1.047
-  =max_ang=: 1.047

******** Allow Unsafe Settings Option

Allow Unsafe Settings Option is not available, please consider using the
legacy [[/hokuyo_node][hokuyo_node]] for UTM-30LX with certain
configurations. (Or provide a
[[https://github.com/ros-drivers/urg_node/issues/3][pull request to
urg_node]] to add support for unsafe_settings.)

******* ROS API

******** hokuyo_node

=hokuyo_node= is a driver for SCIP 2.2 and earlier compliant Hokuyo
laser range-finders.Hokuyo scans are taken in a counter-clockwise
direction. Angles are measured counter clockwise with 0 pointing
directly forward.

********* Published Topics

=scan=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Traditional single return output. This is the most compatible topic
   and represents output from a laser scanner that is not providing
   multiple returns per beam. This topic is not present for multi-echo
   laserscanners in multi-echo modes.

=echoes=
([[http://docs.ros.org/api/sensor_msgs/html/msg/MultiEchoLaserScan.html][sensor_msgs/MultiEchoLaserScan]])

-  Output of a laser scanner capable of multiple returns per beam. This
   is the topic that is designed to give the most information to users
   of [[/LaserScans][LaserScans]]. sensor_msgs/MultiEchoLaserScan is
   not required to be used by clients. This topic is not present for
   single echo laserscanners or multi-echo laserscanners in single echo
   mode.

=first=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Output of the first return from a multi echo laser scanner. This
   topic represents the first return (distance closest to the laser
   scanner). It is typically published by a support library that
   converts sensor_msgs/MultiEchoLaserScans into
   sensor_msgs/LaserScans.

=last=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Output of the last return from a multi echo laser scanner. This topic
   represents the last return (distance furthest from the laser
   scanner). It is typically published by a support library that
   converts sensor_msgs/MultiEchoLaserScans into
   sensor_msgs/LaserScans.

=most_intense=
([[http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html][sensor_msgs/LaserScan]])

-  Output of the most intense return from a multi echo laser scanner.
   This topic represents the most intense return (brightest value). It
   is typically published by a support library that converts
   sensor_msgs/MultiEchoLaserScans into sensor_msgs/LaserScans.

=diagnostics=
([[http://docs.ros.org/api/diagnostic_msgs/html/msg/DiagnosticStatus.html][diagnostic_msgs/DiagnosticStatus]])

-  Diagnostic status information.

********* Parameters

=~ip_address= (=string=, default: "")

-  Location of the device on the network (only valid for ethernet
   devices). If this is left blank or is the empty string, the driver
   assumes the device is serial and will only attempt to connect using
   the '~serial_port' and '~serial_baud' parameters. Hokuyo factory IP
   addresses default to "192.168.0.10".

=~ip_port= (=int=, default: 10940)

-  IP port number. (1 to 65535)

=~serial_port= (=string=, default: /dev/ttyACM0)

-  This represents the serial port device (COM4, /dev/tty/USB0).

=~serial_baud= (=int=, default: 115200)

-  Data transfer rate for a serial device (9600, 115200, and so on)

=~frame_id= (=string=, default: laser)

-  The frame in which laser scans will be returned. This frame should be
   at the optical center of the laser, with the x-axis along the zero
   degree ray, and the y-axis along the 90 degree ray.

=~calibrate_time= (=bool=, default: false)

-  Whether the node should calibrate the device's time offset on
   startup. If true, the node will exchange of series of messages with
   the device in order to determine the time delay in the connection.
   This calibration step is necessary to produce accurate timestamps on
   scans.

=~time_offset= (=double=, default: 0.0)

-  A manually calibrated offset (in seconds) to add to the timestamp
   before publication of a message.

=~publish_intensity= (=bool=, default: false)

-  If true, the laser will publish intensity. If false, the laser will
   not publish intensity to save bandwidth. Should be implemented in
   hardware if possible, but otherwise may be implemented in software.

=~publish_multiecho= (=bool=, default: false)

-  If true, a multiecho laserscanner will publish
   sensor_msgs/MultiEchoLaserScan. If false, the laser will publish
   sensor_msgs/LaserScan. (If supported by the hardware; otherwise,
   please use a support library to convert
   [[/MultiEchoLaserScans][MultiEchoLaserScans]] to
   [[/LaserScans][LaserScans]].) This parameter is only valid for
   multiecho laserscanners.

=~angle_min= (=double=, default: -&pi)

-  Controls the angle of the first range measurement in radians. (If
   supported by the hardware; it is not recommended to implement this
   feature in software.)

=~angle_max= (=double=, default: &pi)

-  Controls the angle of the last range measurement in radians. (If
   supported by the hardware; it is not recommended to implement this
   feature in software.)

=~cluster= (=int=, default: 1)

-  The number of adjacent range measurements to cluster into a single
   reading; the shortest reading from the cluster is reported. (If
   supported by the hardware; it is not recommended to implement this
   feature in software.)

=~skip= (=int=, default: 0)

-  The number of input messages to skip between each output message. The
   device will publish 1 message for every N skipped messages. Example:
   if skip is set to '2', the device will publish 1 message and then
   'drop' the following 2 message - a 66.7% reduction in output rate.
   (If supported by the hardware; it is not recommended to implement
   this feature in software.)

=~diagnostics_tolerance= (=double=, default: 0.05)

-  Fractional percent tolerance for published scan frequency to vary
   from expected. 0.05 is 5%, so for 40Hz it means acceptable limits
   between 38Hz and 42Hz.

=~diagnostics_window_time= (=double=, default: 5.0)

-  Number of seconds in which to consider published data to determine
   publish frequency for diagnostics.

******* Command-Line Tools

The =getID= program can be used to get information about a hokuyo laser
scanner. Each of them can be invoked in a human readable way:

#+BEGIN_EXAMPLE
    $ rosrun hokuyo_node getID /dev/ttyACM0
    Device at /dev/ttyACM0 has ID H0807228
#+END_EXAMPLE

or in a script friendly way:

#+BEGIN_EXAMPLE
    $ rosrun hokuyo_node getID /dev/ttyACM0 --
    H0807228
#+END_EXAMPLE

If they fail to connect to the device they will retry for about ten
seconds before giving up.

******* Using udev to Give Hokuyos Consistent Device Names

The =getID= program can be used to get the hardware ID of a Hokuyo
device given its port. Combined with udev, this allows a consistent
device name to be given to each device, even if the order in which they
are plugged in varies. On the PR2 we use the following udev rule:

#+BEGIN_EXAMPLE
    SUBSYSTEMS=="usb", KERNEL=="ttyACM[0-9]*", ACTION=="add", ATTRS{idVendor}=="15d1", ATTRS{idProduct}=="0000", MODE="666", PROGRAM="/opt/ros/hydro/lib/urg_node/getID /dev/%k q", SYMLINK+="sensors/hokuyo_%c", GROUP="dialout"
#+END_EXAMPLE

This udev rule sets up a device name that is based on the Hokuyo's
hardware ID. The PR2 then has a symlink to that name that gets changed
if the Hokuyo is replaced:

#+BEGIN_EXAMPLE
    $ ls -l /etc/ros/sensors/base_hokuyo
    lrwxrwxrwx 1 root root 28 2010-01-12 15:53 /etc/ros/sensors/base_hokuyo -> /dev/sensors/hokuyo_H0902620
    $ ls -l /dev/sensors/hokuyo_H0902620
    lrwxrwxrwx 1 root root 10 2010-04-12 12:34 /dev/sensors/hokuyo_H0902620 -> ../ttyACM1
#+END_EXAMPLE

Wiki: urg_node (last edited 2014-08-13 21:36:19 by
[[/ChadRockey][ChadRockey]])

Except where otherwise noted, the ROS wiki is licensed under the\\
[[http://creativecommons.org/licenses/by/3.0/][Creative Commons
Attribution 3.0]] |
[[https://plus.google.com/113789706402978299308][Find us on Google+]]

--------------

[[/custom/images/brought_by_horiz.png]]

**** TCB 在Emacs使用文件管理器打开目录，而不是 Emacs 本身
:LOGBOOK:
- State "Tcb"        from "TODO"       [2016-03-04 五 11:59] \\
  没事可以折腾
:END:

[[~/Document]]

https://github.com/jixiuf/org-mode-files/blob/master/emacs/open-with.org
也许可以参考

C-u C-u C-x C-o 无效

其实没有必要，也没有意义。

**** DONE 远程连接 ROS
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-03-04 五 15:34]
- State "TODO"       from ""           [2016-03-04 五 15:01]
:END:

1. 为从机设置 ROS_MASTER_URI

   #+BEGIN_EXAMPLE
   export ROS_MASTER_URI=http://192.168.1.3:11311
   #+END_EXAMPLE

2. 分别为主机和从机设置  ROS_IP

   #+BEGIN_EXAMPLE
   export ROS_IP=`hostname -I`
   #+END_EXAMPLE

   或者直接写入 .bashrc

3. 谁主谁从?

   *配置好的为主*

**** DONE 配置 hokuyo ID
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-03-04 五 18:34]
- State "TODO"       from ""           [2016-03-04 五 17:20]
:END:

http://wiki.ros.org/urg_node
http://wiki.ros.org/hokuyo_node

测试 urg_node 页面上的 udev 规则, 没有成功.

测试 hokuyo_node 页面上的 udev 规则,  OK

#+BEGIN_EXAMPLE
  ll@ll-OEM:~$ ls -l /dev/ttyACM*
  crw-rw-rw- 1 root dialout 166, 0  3月  4 18:32 /dev/ttyACM0
  crw-rw-rw- 1 root dialout 166, 1  3月  4 18:32 /dev/ttyACM1
  ll@ll-OEM:~$ ls -l /dev/sensors/
  总用量 0
  lrwxrwxrwx 1 root root 10  3月  4 18:32 hokuyo_H1004293 -> ../ttyACM0
  lrwxrwxrwx 1 root root 10  3月  4 18:32 hokuyo_H1007634 -> ../ttyACM1
#+END_EXAMPLE

udev 规则

#+BEGIN_EXAMPLE
ll@ll-OEM:~$ cat /etc/udev/rules.d/hokuyo.rules
KERNEL=="ttyACM[0-9]*", ACTION=="add", ATTRS{idVendor}=="15d1", MODE="0666", GROUP="dialout", PROGRAM="/opt/ros/indigo/env.sh rosrun hokuyo_node getID %N q", SYMLINK+="sensors/hokuyo_%c"
#+END_EXAMPLE

/修改 ROS 版本/

**** DONE 上电自启配置
:LOGBOOK:
- State "DONE"       from ""           [2016-03-09 三 11:55] \\
  自己浏览手册时没有解决，咨询售方，收到相关指导文档，很快解决。
  使用关键字搜索手册，找到对应方法，说明阅读得还不够仔细
:END:

1. 启动时按 <DEL> 进入 BIOS
2. 依次 Intergrate Peripherals -> Super IO Device -> PWRON After
   PWR-fail

   [[/home/wally/Wally/Journal/Figure/scrot/2091CGN.png]]

*** ROS

**** stack

***** camon_description

***** camon_launch

****** microstrain.launch

****** lidar.launch

id

#+BEGIN_EXAMPLE
  s$ ls -l /dev/sensors/
  总用量 0
  lrwxrwxrwx 1 root root 10  3月 10 15:22 hokuyo_H1004293 -> ../ttyACM0
  lrwxrwxrwx 1 root root 10  3月 10 15:22 hokuyo_H1007634 -> ../ttyACM1
#+END_EXAMPLE

****** urg.launch

**** miscellaneous

***** 编译 ROS 包时出错

#+BEGIN_EXAMPLE
CMake Error: your CXX compiler: "CMAKE_CXX_COMPILER-NOTFOUND" was not found.
#+END_EXAMPLE

[[http://answers.ros.org/question/196915/invoking-cmake-failed/][Q&A]]

It seems you do not have any C++ compilers installed. You must first
install one to use catkin like this. Try opening up a terminal and
then typing:

#+BEGIN_EXAMPLE
sudo apt-get install build-essential -y
#+END_EXAMPLE

Then the g++ compiler should be installed.

***** Hector SLAM 的安装

1. 使用 apt-get 方式安装需要安装依赖的软件 100+M
2. 下载源码完整编译 hector-slam, CMake 也依赖许多其它包

尝试单独编译 hector-mapping
1. 依赖 laser_assemble
2. 依赖 tf_conversion
测试 OK

更好的方法使用 apt-get 安装 package 而不是 stack
#+BEGIN_EXAMPLE
$ sudo apt-get install ros-indigo-hector-mapping
#+END_EXAMPLE

***** 搭建 Git 本地服务器

文件传输： NFS vs Git

*Of course git*

#+BEGIN_EXAMPLE
  ssh: connect to host localhost port 22: Connection refused
  fatal: Could not read from remote repository.

  Please make sure you have the correct access rights
#+END_EXAMPLE

没有安装 openssh-server


输入密码后 permission denied

检查 git 用户 shell 设置

#+BEGIN_SRC sh
cat /etc/passwd | grep git
#+END_SRC

#+RESULTS:
| git:x:1001:1001:git |   |   | :/home/git:/usr/local/bin/git-shell |

git-shell 的路径是否正确

***** 开启网口激光后上网有问题
*** pcltk

#+include: ~/Wally/Project/catkin_ws/src/pcltk

**** Reference

- [[http://wiki.ros.org/perception_pcl/Tutorials][ROS wiki: use pcl in ROS]]
- [[http://www.pointclouds.org/documentation/tutorials/][PCL official tutorials]]

**** Note

1. 在 ROS 中使用 PCL，这样运行起来比较方便，可以使用 rosrun
2.

**** TODOs

**** ChangeLogs

+ 2016/01/22

  - create the catkin package pcltk which I think is a nice name
  - initialize the PRIME pcltk with <Reference> <Note> <TODOs> and <ChangeLogs>
  - organize existing src files, concluding merge_pcl, downsampling, write_pcds

**** ROS demo

External dependencies in /package.xml/

#+BEGIN_SRC xml
  <build_depend>libpcl-all-dev</build_depend>
  <run_depend>libpcl-all</run_depend>
#+END_SRC

#+include: ~/Wally/Project/catkin_ws/src/pcltk/src/example.cpp

**** data strucuture

- sensor_msgs::PointCloud :: ROS message, deprecated (废弃)

     #+BEGIN_EXAMPLE
       std_msgs/Header header
         uint32 seq
         time stamp
         string frame_id
       geometry_msgs/Point32[] points
         float32 x
         float32 y
         float32 z
       sensor_msgs/ChannelFloat32[] channels
         string name
         float32[] values
     #+END_EXAMPLE

- snesor_msgs::PointCloud2 :: ros message

     #+BEGIN_EXAMPLE
       std_msgs/Header header
         uint32 seq
         time stamp
         string frame_id
       uint32 height
       uint32 width
       sensor_msgs/PointField[] fields
         uint8 INT8=1
         uint8 UINT8=2
         uint8 INT16=3
         uint8 UINT16=4
         uint8 INT32=5
         uint8 UINT32=6
         uint8 FLOAT32=7
         uint8 FLOAT64=8
         string name
         uint32 offset
         uint8 datatype
         uint32 count
       bool is_bigendian
       uint32 point_step
       uint32 row_step
       uint8[] data
       bool is_dense
     #+END_EXAMPLE

- pcl::PCLPointCloud2 :: pcl data structure mostly for compatibility
     with ROS
- pcl::PointCloud :: standard PCL data structure

**** about local documents

1. HTML vs PDF： 前者

2. wget vs doxygen: 后者

   - wget 又慢以乱

   - doxygen 才是正宗

3. doxygen

   - 编译时安装： http://www.pointclouds.org/documentation/tutorials/generate_local_doc.php

   - 手动执行 doxygen: 修改 doxygen 配置文件, 很不爽

4. 别管这些次要的了

**** PointCloud :: [[http://www.pointclouds.org/documentation/tutorials/basic_structures.php#basic-structures][Basic Structure]]

To simplify development, the PointCloud class contains a number of
helper member functions. For example, users don’t have to check if
height equals 1 or not in their code in order to see if a dataset is
organized or not, but instead use *PointCloud()*:

#+BEGIN_SRC cpp
if (!cloud.isOrganized ())
#+END_SRC

**** writing point cloud data to PCD files

http://www.pointclouds.org/documentation/tutorials/basic_structures.php#basic-structures

#+include: ~/Wally/Project/pcl_tutorials/src/pcd_write.cpp

***** PointCloud

http://docs.pointclouds.org/trunk/classpcl_1_1_point_cloud.html#details

****** attributes

[[http://www.pointclouds.org/documentation/tutorials/basic_structures.php#basic-structures][Doc:PointClou]]d

- width
- height
- points
- is_dense
- sensor_origin
- senor_orientation

****** methods

***** 头文件

头文件位置 =/usr/include/pcd-1.7/pc/=

#+BEGIN_SRC cpp
#include <pcl-1.7/pcl/io/pcd_io.h>
#include <pcl-1.7/pcl/point_types.h>
#+END_SRC

创建 link

#+BEGIN_EXAMPLE
 ~ $ ls -l /usr/include/pcl
lrwxrwxrwx 1 root root 24  1月  7 09:53 /usr/include/pcl -> /usr/include/pcl-1.7/pcl
#+END_EXAMPLE

***** CMakeLists.txt

#+include: ~/Wally/Project/pcl_tutorials/CMakeLists.txt

**** [[http://www.pointclouds.org/documentation/tutorials/voxel_grid.php#voxelgrid][ownsampling a PointCloud using a VoxelGrid filter]]

- *downsample*: reduce the number of points
- using a *voxelized grid* approach

#+include: ~/Wally/Project/pcl_tutorials/src/voxel_grid.cpp

**** Merge PCDs

***** concatenate the points of two points clouds

http://pointclouds.org/documentation/tutorials/concatenate_clouds.php

#+include: ~/Wally/Project/pcl_tutorials/src/concatenate_clouds.cpp

***** merge_pcl

http://docs.ros.org/hydro/api/cob_3d_mapping_tools/html/merge__pcds_8cpp_source.html

#+INCLUDE: ~/Wally/Project/catkin_ws/src/wally/wally_launch/src/merge_pcds.cpp

**** downsampling

#+include: ~/Wally/Project/catkin_ws/src/wally/wally_launch/src/downsample.cpp

**** PCL

- 先保存为 pointcloud2
- 之后 downsampling

***** data structure

PCL has about four different ways of representing point cloud data

- sensor_msgs::PointCloud — ROS message (*deprecated*)
- *sensor_msgs::PointCloud2* — ROS message
- pcl::PCLPointCloud2 — PCL data structure mostly for compatibility with ROS (I think)
- *pcl::PointCloud<T>* — standard PCL data structure

***** laser_assembler

**** miscellaneous
***** catkin_package()

编译生成的可执行文件位置 devel/lib/pkg/node

如果在 CMakeLists.txt 中忘记 catkin_package() 宏

生成的位置将变为 build/pkg/node

rosrun 等命令行工具也会找不到指定节点

*** backpack-slam

#+include: ~/Wally/Project/backpackslam

http://www-video.eecs.berkeley.edu/research/indoor/

**** reference

***** [[~/Wally/GraduationProject/Literature/liu2010indoor.pdf][liu2010indoor]]

****** bib

@inproceedings{liu2010indoor,
  title={Indoor localization and visualization using a human-operated backpack system},
  author={Liu, Timothy and Carlberg, Matthew and Chen, George and Chen, Jacky and Kua, John and Zakhor, Avideh},
  booktitle={Indoor Positioning and Indoor Navigation (IPIN), 2010 International Conference on},
  pages={1--10},
  year={2010},
  organization={IEEE}
}

****** literature

1. SLAM [1]
2. 6D SLAM [2-4]
3. ICP [5]
4. loop closure [3, 8-10]
5. backpack slam [11]

***** [[~/Wally/GraduationProject/Literature/chen2010indoor.pdf][chen2010indoor]]

****** bib

@inproceedings{chen2010indoor,
  title={Indoor localization algorithms for a human-operated backpack system},
  author={Chen, George and Kua, John and Shum, Stephen and Naikal, Nikhil and Carlberg, Matthew and Zakhor, Avideh},
  booktitle={3D Data Processing, Visualization, and Transmission},
  year={2010},
  organization={Citeseer}
}

***** [[~/Wally/GraduationProject/Literature/kua2012automatic.pdf][kua2012automatic]]

****** bib

@inproceedings{kua2012automatic,
  title={Automatic loop closure detection using multiple cameras for 3d indoor localization},
  author={Kua, John and Corso, Nicholas and Zakhor, Avideh},
  booktitle={IS\&T/SPIE Electronic Imaging},
  pages={82960V--82960V},
  year={2012},
  organization={International Society for Optics and Photonics}
}

***** [[~/Wally/GraduationProject/Literature/naikal2009image.pdf][naikal2009image]]

****** bib

@inproceedings{naikal2009image,
  title={Image augmented laser scan matching for indoor dead reckoning},
  author={Naikal, Nikhil and Kua, John and Chen, George and Zakhor, Avideh},
  booktitle={Intelligent Robots and Systems, 2009. IROS 2009. IEEE/RSJ International Conference on},
  pages={4134--4141},
  year={2009},
  organization={IEEE}
}

*** Navigator
**** Navigator Manul
***** 操作注意事项
+ 开机，四伺服处于闭环状态，锁死电机，勿动
+ 每月充电，保证电池性能
+ 载重小于80Kg
***** 特点
Navigator Q2 是四轮 45 度全向轮轮系的机器人平台, 使用航发
公司的 QMA-15 全向轮,与传统轮系相比,能够实现平移、自转、平
移并自转等特殊运动。
***** 性能指标
+ 驱动方式： 四轮独立驱动
+ *悬挂形式：液压阻尼避震器悬挂* ???
+ 负载：80KG
+ 电机类型： *空心杯直流伺服电机*
+ 电机额定功率： 90W
+ 电机编码器： 500线/转，A、B相输出
+ 电机驱动： 伺服驱动器，CAN总线，RS232通信接口
+ 最大移动速度： 1.2m/s
+ 最大自转速度：145°/s
+ 最小转弯半径：0
+ 电池 24V/18.2Ah锂电池

***** 电机驱动器

美国Copley Control公司 *ACJ-055-18* 高性能直流伺服驱动器


#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:21:43
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:21:43.png]]

***** 电路硬件

****** 16路超声测距传感器板

****** 电源板

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:28:25
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:28:25.png]]

+ 24V
+ 12V
+ 5V


#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:30:33
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:30:33.png]]
通信方式
+ CAN总线
+ UART串口，TTL电平

****** 运动控制卡

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:31:21
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:31:21.png]]

1. 运动控制方式
   + 步进电机方式？？
   + CAN总线（独立）
   + 串口命令方式

2. 模式
   + 速度模式：接收命令后立即执行，没有后续命令则持续到设置默认时间结
     束
   + 位置模式：先保存到命令队列，收到开始命令后才按顺序执行

****** 主控板
1. *STM32F407VE*
   + 32位
   + ARM Cortex-M4F
   + 168M主频
   + 210MIPS
   + 512K FLASH
   + 196K SRAM
   + LQFP 封装

2. 资源
   + 两个RS232电平UART串口
     - 一个可以直接连接到PC串口
     - 一个以3Pin白端子连接到其他设备
   + 一个TTL电平的UART串口，可以连接其它需要控制端的设备
   + 一个RS485接口
   + 一个TF卡接口，使用SPI总线
   + 一个TFT LCD接口，使用FSMC，带SPI接口，和TF卡接口共用
   + 两路CAN总线接口
   + 8个ADC输入
   + 两个DAC输出
   + 8个PWM输出
   + 一个I2C接口，和PWM2，PWM3复用
   + 标准20针JTAG接口

3. 尺寸：86mm*100mm

****** OFPS定位模块
+ 短时间内对机器人运动轨迹进行辅助定位
+ 三个码盘
+ CAN总线和UART串口
+ STM32F4


#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 10:52:04
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_10:52:04.png]]

****** Pathfinder遥控器

**** RHF407
***** 处理器
****** 时钟、启动与复位
+ 主时钟： 25M无源晶振
+ 启动方式： BOOT0接地，总是从用户FLASH启动
+ 备份电源：使用可充电纽扣锂电池
+ 复位电路：SP809芯片
  #+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:14:04
  [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:14:04.png]]
****** JTAG
JTAG: JTAG254-10x2
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:25:53
[[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:25:53.png]]

****** 电源电路
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:37:35
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:37:35.png]]

+ D1 SS14 反压保护
+ LM1117-3.3稳压
+ FB1/FB2磁珠滤波给模拟电路供电

****** LED 指示灯

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:42:53
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:42:53.png]]

使用 *倒灌式* 连接

****** 按键电路

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:43:58
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:43:58.png]]

+ 外部上拉
+ 电容滤波
****** RS232串口
*MAX3232*
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 11:44:54
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_11:44:54.png]]

+ 2路
+ 一路串口接到DB9孔式插座
+ 一路接到端子插座

****** TTL串口电路

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:07:55
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:07:55.png]]

直接从处理器连接到端子，同时提供3whIO口线作控制用。

****** RS485电路
*SP3485* or *MAX3485* 电平转换
#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:09:54
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:09:54.png]]

JP7的1，2引脚短路时使用终端阻抗匹配电阻

****** CAN总线电路

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:21:32
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:21:32.png]]

驱动芯片 *SN65HBD230*

****** USB

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:22:57
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:22:57.png]]

+ 处理器有两路USB，这是使用全速OTG端口
+ 作为主机时应用不多，仅做从机。

****** TF卡

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:25:02
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:25:02.png]]

TF卡使用SPI总线连接方式，各种信号都外接上拉电阻。

****** LCD

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:26:46
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:26:46.png]]

接口兼容神州王3.2寸TFT模块。

****** ADC

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:28:18
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:28:18.png]]

直接接到处理器口线上，使用时必须保证不能超过处理器的极限条件以损坏处理
器，否则输入前需要添加保护电路。

****** DAC

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:31:02
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:31:02.png]]
处理器线口直接输出，还可以做ADC使用。

****** PWM

#+DOWNLOADED: /tmp/screenshot.png @ 2015-06-29 14:32:04
 [[~/Wally/Journal/Figure/Navigator/screenshot_2015-06-29_14:32:04.png]]

处理器接口直接输出，可以接舵机或其它设备。

***** 开发环境

+ MDK：ARM7, ARM9, 部分Cortex
+ IAR：ARM11, Cortex-A9

+ 基于GNU的：emIDE

***** 芯片

****** AMS1117电源转换
1. Features
   + dropout voltage 1.2v 压差
   + Line regulation 0.2% max
   + Load regulation 0.4% max
   + Current limiting and Thermal Protection
   + Adjustable Output Voltage or Fixed 1.25V, 1.5V, 1.8V, 2.5V, 2.85V, 3.3V, 5V
   + Maxumum Input Voltage 15V


****** STM32F407VE

******* ICP & IAP
1. *in-circuit programming(ICP)*
   + JTAG
   + SWD
   + the boot loader
2. *in-application programming(IAP)* can use any communication
   interface supported by the microcontroller(I/Os, USB, CAN, UART,
   I2C, SPI, etc.) to download data into memory,  With IAP, the Flash
   memory can be reprogrammed while the application is running,
   Nevertheless, part of the application has to have been previously
   programmed in the Flash memory using ICP

******* Glossary
+ The CPU nitegrates two debug ports:
  - *JTAG debug port(JTAG-DP)* provides a 5-pin standard interface
    based on the *Joint Test Action Group(JTAG)* protocal
  - *SWD debug port(SWD-DP)* provides a 2-pin(clock and data)
    interface based on the *Serial Wire Debug* protocal
+ *word*: data/instruction of 32-bit length
+ *Half world*: data/instruction of 16-bit length
+ *Byte*: data of 8-bit length
+ *Double word*: data of 64-bit length
+ *IAP(in-application programming)*: IAP is the ability to reprogram
  the Flash memory of a microcontroller while the user program is running.
+ *ICP(in-circuit programming)*: ICP is the ability to program the
  Flash memory of a microcontroller using the JTAG protocol, the SWD
  protocol or the bootloader while the device is mounted on the user
  application board.
+ *I-Code*: this bus connects the Instruction bus of the CPU core to
  the instruction interface. Prefetch is performed on this bus.
+ *D-Code*: this bus connects the D-Code bus(literal load and debug
  access) of the CPU to the Flash data interface.
+ *OBL*: option byte loader
+ *AHB*: advanced high-preformance bus

*****

**** CAN

*CAN(Controller Area Network)* 控制器局域网

CAN总线是唯一成为国际标准的现场总线，也是国际上应用最为广泛的现场总线
之一。

+ 成本低
+ 传输距离远(<10Km)
+ 传输速率高（1Mb/s）


层： OSI开放系统互连模型

+ 物理介质：双绞线（常用），光纤

+ 信号线： *CAN_H* 和 *CAN_L*
  - 静态时均为2.5V。状态表逻辑1，也称隐形
  - CAN_H(3.5V)比CAN_L(1.5V)高表逻辑0, 称显形

+ 标准CAN的标志符长度为11位，扩展格式可达29位

+

**** Navigator

***** note

1. STM32 主控
2. 模块化： 每一个模块通过 CAN 或 UART 可以发送命令或接收数据
3. 可编程！！！
4. 有内部使用的CAN控制器
5. 使用CAN

***** 需要用它干嘛？

1. 获取编码器数据用于计算位置
2. 发送控制指令
3. 指令的封装？？ ROS how?

***** 暂时没有能力做这件事情。。。。

***** 复制到 Reference 目录下新建的 Product 文件夹下

* Project                                                           :proj:

#+include: ~/Wally/Project/README.md
#+include: ~/Wally/Project/ChangeLog.org

** README

1. 任务要有优先级
2. 学习任务放在对应的笔记文件中，方便整理笔记，此处仅记录链接
3. 不打标签，仅在本文件链接上打标签
4. 第一个学习任务对应一个项目
5. 拟名字要认真，不要轻易改，有链接

** toolbox

#+include: ~/Wally/Project/toolbox/README.md
#+include: ~/Wally/Project/toolbox/ChangeLog.txt

*** DONE Links to pdf
- State "DONE"       from ""           [2015-12-18 五 09:45] \\
  1) wkhtmltopdf 原生支持多个网页，只要在命令行中依次给出 url 即可，用不
     着写这样麻烦劣质的东西
  2) 使用英文注释，不要使用中文注释
  3) 不要在代码中加入无关的东西，注释中不要添加关于语言的用法，这是笔记
     的事情


#+BEGIN_SRC sh
  #! /bin/bash

  ## 功能
  ##    1. 使用wkhtmltopdf将多个网页转换为pdf
  ##    2. 使用gs合并生成的多个PDF
  ##    3. 使用pdfoutline合并的PDF生成目录

  ## 格式： links2pdf index
  ## 输入： index为文件，包含链接和章节信息
  ##       index每行为一个链接
  ##       line: link---chapter---level


  ## version 0.2 --- 添加注释
  ## version 0.3 --- 类似CMake的外部编译，在目录build下进行

  index=$1
  builddir=links2pdf_build
  mkdir $builddir
  cd $builddir
  cp ../$index .

  > outline                       # 利用重定向生成空文件
  declare -i counter=0            # 限制变量counter的属性为整型，counter用于计算章节数
  declare -i page=1               # page用于跟踪页数
  cat $index | while read -r line
  do
      counter=counter+1           # "整型"变量可以直接进行数值计算， 一般变量需要通过$(())

      # ${} 字符串处理
      link=${line%%\ *}           # %去尾，双%匹配最长，即删除尾部与模式匹配的最大子字符串
      level=${line##*\ }          # #支头，双#匹配最长，即删除头部与模式匹配的最大子字符串
      # range=$((len3-len1-len2-2))       # range???  len<N>??? 明显多余
      link_chapter=${line%\ *}    # %去尾，单%匹配最短，即删除尾部与模式匹配的最小子字符串

      # #去头，单#匹配最短，即删除头部与模式匹配的最小子字符串
      # 前提是link中无空格，章节中可能存在空格
      chapter=${link_chapter#*\ }

      # 9是幻数，含义是小于10的章节索引有前缀0，即01,02... 便于gs排序
      if test ${counter} -gt 9    # test 或 [ condition ]
         then
                 wkhtmltopdf --no-outline $link $counter.pdf; # HTML to PDF
                 Pages=$(pdfinfo $counter.pdf | grep Pages);  # $() 或 反引号`` 执行shell命令并c返回
                 num=${Pages##*\ };
      else
          wkhtmltopdf --no-outline $link 0${counter}.pdf;
          Pages=$(pdfinfo 0${counter}.pdf | grep Pages);
          num=${Pages##*\ };
      fi
      echo "$level $page $chapter" >> outline
      page=$((page+num))          # $(()) 数值运算，变量page已经声明为“整型”，也可以不包裹
  done


  # gs
  gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=out.pdf  *.pdf

  # pdfoutline
  pdfoutline out.pdf outline output.pdf

  # 删除文件
  mv output.pdf ..
  cd ..
  rm -rf $builddir

#+END_SRC

*** Track 规范化 standardize file name                     :filename:stdfn:
- State "Track"      from ""           [2015-12-18 五 10:48] \\
  1. 小结
     + 文件命名要有规范，最好不要仅使用下划线连接几个单词，好丑
     + 不要使用中文注释

  2. TODOs
     + 多个路径参数
     + 参数检查
     + 递归遍历
     + 使用正则替换所有除下划线、数字和字母外的所有特殊字符为下划线

#+INCLUDE: ~/Wally/Project/toolbox/src/stdfn.sh

*** convert pptx to pdf in batch                             :ppt:pptx:pdf:

#+INCLUDE: ~/Wally/Project/toolbox/src/pptx2pdf.sh

*** merge PDFs with outline

#+INCLUDE: ~/Wally/Project/toolbox/src/mergepdfs.sh

*** NEXT remove backfile ended with ~ recursively
- State "NEXT"       from ""           [2015-12-20 日 23:03] \\
  not working well. ls may be the problem

#+INCLUDE: ~/Wally/Project/toolbox/src/debackup.sh

*** NEXT project
- State "NEXT"       from "TODO"       [2015-12-21 一 19:17] \\
  写了简单的 project 脚本，仅生成 .projectile, README.md, ChangeLog.txt
  文件和 test 目录
- State "TODO"       from ""           [2015-12-18 五 11:44] \\
  更简洁些，不要多余的功能

#+INCLUDE: ~/Wally/Project/toolbox/src/project.sh

**** project
#+BEGIN_SRC sh
   #! /bin/sh

  # tagerill_update_project.sh

  # version 1.0
  # This is a bash script to initialize a new project of common sense
  # It mainly finishes the following tasks
  # 1. create a new root directory that named by the first arguments
  # 2. create a README file containing information like timestamps,
  #    author, email, license and so on
  # 3. create a .projectile file for the convinence of Projectile to manage it
  #
  # version 1.1
  # add the function of update a project
  #
  # Usage
  # tagerill_new_project.sh <PROJECT> [COMMENT_STR]
  #
  # TODO
  # [ ] select a rule of naming versions & update the version information


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "error: wrong number of arguments"
      echo "usage: tagerill_new_project.sh <PROJECT> [COMMENT_STR]"
      exit -1
  fi


  project=$1
  comments=""
  if [ $# -eq 3 ]
  then
      comments=$2
  fi

  # update the project
  if [ -d $project ]
  then
     cd $project
     echo >> README
     echo -n "MODIFICATION:" >> README
     date +%Y/%m/%d-%H:%M >> README
     # TODO： 变更版本信息
     if [ $# -eq 3 ]
     then
         echo "COMMENT: $comments" >> README
     fi
     echo "Project: $project updated."
     exit 0
  fi


  # create a new project
  # root workspace
  mkdir $project

  # README
  cd $project
  touch README
  echo "PROJECT: $project" >> README
  echo "VERSION: v1.0"
  echo -n "TIME: " >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "License: GPL v3.0" >> README

  # .projectile
  touch .projectile

  #
  echo "Project: $project has been created"

  exit 0

#+END_SRC

**** cpp

#+BEGIN_SRC sh
  #! /bin/sh

  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: cpp_pro.sh PROJECT"
      exit 1
  fi

  project=$1
  mkdir $project
  cd $project
  touch README COPYRIGHT TODO Makefile
  mkdir bin src include lib

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
  echo [ ] >> TODO
#+END_SRC

**** cmake

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "usage: cmake_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  # 目录结构
  mkdir src scripts build lib bin doc

  # 根目录下文件
  touch CMakeLists.txt
  echo "CMAKE_MINIMUM_REQUIRED(VERSION 3.2)" >> CMakeLists.txt
  echo "PROJECT($project)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(src bin)" >> CMakeLists.txt
  echo "ADD_SUBDIRECTORY(scripts)" >> CMakeLists.txt

  touch README COPYRIGHT TODO
  echo "PROJECT: $project" >> README
  echo -n "TIME: " >> README
  date +%Y/%M/%d-%H:%m >> README
  echo "AUTHOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # src
  cd src
  touch CMakeLists.txt

  # scripts
  cd ../scripts
  touch CMakeLists.txt
  echo "# INSTALL(PROGRAMS project DESTINATION bin)" >> CMakeLists.txt
#+END_SRC

**** arduino

#+BEGIN_SRC sh
  #! /bin/bash

  # 参数个数检查
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of argument"
      echo "usage: ardpro PROJECT"
      exit
  fi

  project=$1
  mkdir $project                  # 创建目录
  cd $project
  touch README COPYRIGHT TODO Makefile $project.ino

  # README
  echo PROJECT: $project >> README
  echo -n TIME: >> README
  date +%Y/%m/%d-%H:%M >> README
  echo "AUTOR: Tagerill Wong" >> README
  echo "EMAIL: buaaben@163.com" >> README
  echo "LICENSE: GPL v3.0" >> README

  # TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO
  echo "[ ]" >> TODO

  # Makefile
  echo "BOARD_TAG = uno" >> Makefile
  echo "ARDUINO_LIBS = " >> Makefile
  echo "MONITOR_PORT = /dev/ttyACM0" >> Makefile
  echo "include /usr/share/arduino/Arduino.mk" >> Makefile
#+END_SRC

**** bash

#+BEGIN_SRC sh
  #! /bin/bash

  # Function: Create a new bash project
  # Usage: bash_pro.sh
  # Input: Project name
  # Output: Name


  # Input check
  if [ $# -lt 1 ] || [ $# -gt 2 ]
  then
      echo "Wrong number of arguments"
      echo "Usage: bash_pro.sh PROJECT"
      exit
  fi

  project=$1
  mkdir $project
  cd $project
  touch README LICENSE TODO Makefile      # Files
  mkdir scripts bin               # Contents

  # REAMDE
  echo "Project: $project" >> README
  echo -n "Time: " >> README
  date +%Y/%m/%d-%H:%m >> README
  echo "Author: Wally" >> README
  echo "Email: buaaben@163.com" >> README
#+END_SRC

**** CMakelists.txt

#+BEGIN_SRC cmake
  CMAKE_MINIMUM_REQUIRED(VERSION 3.2)
  PROJECT(bash_pro)
  ADD_SUBDIRECTORY(src bin)
  ADD_SUBDIRECTORY(scripts)

  INSTALL(PROGRAMS bash_pro.sh DESTINATION bin)
#+END_SRC
*** TODO routine


#+INCLUDE: ~/Wally/Project/toolbox/src/routine.sh

TODOs
+ [ ] [[file:~/Wally/Project/toolbox/src/routine.sh::path=$1%20#%20path%20need%20to%20be%20absolute][check path]]




#+BEGIN_SRC sh
  #! /bin/sh

  # 执行git, pdf, clean等日常工作
  # 根据时间和地点完成不同的任务

  home=tiger                      # 用户名
  office=ben
  host=`echo $HOSTNAME`
  ws=$HOME/Wally/Journal  # workspace
  emacs_settings_ws="/home/${host}/.emacs.d"


  time=`date +%H`

  cmd=$1

  # if [ $time -gt $line ]                # in the evening
  # then
  #     if [ $host == $office ]   # at office
  #     then
  #       # clean
  #       touch tmpfile
  #       rm `ls . | grep -E "*~$|*.out$|*.log$|*.toc$|*.aux$|^tmpfile$"`
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $office `date +%H%M`"
  #       git push origin master

  #       # pdf
  #       journal=journal.pdf
  #       if [ -e $journal ]
  #       then
  #           mv journal.pdf "PDFs/`date +%Y%m%d`.pdf"
  #       fi
  #     elif [ $host == $home ]                   # at home
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/master
  #     fi
  # else                          # in the morning
  #     if [ $host == $office ]
  #     then
  #       # git pull
  #       git pull
  #       git merge origin/home
  #     elif [ $host == $home ]
  #     then
  #       # git push
  #       git add --ignore-removal .
  #       git commit -m "committed automatically by script at $home at `date +%H:%M`"
  #       git push origin home
  #     fi
  # fi


  if [ $cmd = "push" ]
  then
      cd $ws
      git add --ignore-removal .
      git commit -m "committed automatically by script at $home at `date +%H:%M`"
      git push origin master

      if [ $host = $office ]
      then
          cd $emacs_settings_ws
          git add settings.org
          git add elpa/yasnippet-20150323.311/snippets/
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
          git push origin master

          thesis_ws="~/Wally/GraduationProject/Thesis"
          cd $thesis_ws
          git add .
          git commit -m "committed automatically by script at $home at `date +%H:%M`"
      fi
  elif [ $cmd = "pull" ]
  then
      cd $ws
      git pull
  fi


  # 命令行参数为密码
  # if [ $# -eq 1 ]
  # then
  #     passwd=$1
  #     python email_evernote.py $passwd
  # fi

  # dict

#+END_SRC

*** TODO email

#+BEGIN_SRC python
  #! /usr/bin/env python
  # -*- encoding:utf-8 -*-

  import smtplib

  from email import encoders
  from email.header import Header
  from email.mime.text import MIMEText
  from email.mime.multipart import MIMEMultipart
  from email.mime.base import MIMEBase
  from email.utils import parseaddr, formataddr

  import sys, datetime, os

  if len(sys.argv) < 2:
      print "done nothing. If a email needs to be delieved, please confirm and provide the passwd"
      exit(0)

  def _format_addr(s):
      name, addr = parseaddr(s)
      return formataddr((Header(name, 'utf-8').encode(), addr))

  pdf_file = "%s.pdf" % datetime.datetime.now().strftime("%Y%m%d")
  path = "/home/ben/Wally/Journal/PDFs/"
  filename = path + pdf_file

  from_addr = "buaaben@163.com"
  passwd = sys.argv[1]            # 从命令行获取密码
  to_addr = "buaaben.fa289a0@m.yinxiang.com"

  # 构造邮件对象
  msg = MIMEMultipart()
  # 发送地址
  msg['From'] = _format_addr("Ben<%s>" % from_addr)
  # 接收地址
  msg['To'] = _format_addr('Evernote<%s>' % to_addr)
  # 主题
  msg['Subject'] = Header("%s @Tagerill #journal" %
                          datetime.datetime.now().strftime("%Y%m%d"),
                          'utf-8').encode()

  # 时间戳
  now = datetime.datetime.now().strftime('%Y/%m/%d-%H:%M')
  msg.attach(MIMEText('Generated automatically by python script at %s' % now,
                      'plain', 'utf-8'))
  # 正文
  with open("/home/ben/dic.txt", 'r+') as f:
      voc = f.read()
      msg.attach(MIMEText('Vacabularies for today are as following: %s' % voc,
                          'plain', 'utf-8'))
      null = ''
      f.write(null)

  # 附件
  if os.path.exists(filename):
      with open(filename, 'rb') as f:
          mime = MIMEBase('PDF', 'pdf', filename='journal.pdf')
          mime.add_header('Content-Disposition', 'attachment',
                          filename='journal.pdf')
          mime.add_header('Content-ID', '<0>')
          mime.add_header('X-Attachment-Id', '0')

          # 把附件的内容读进来:
          mime.set_payload(f.read())
          # 用Base64编码:
          encoders.encode_base64(mime)
          # 添加到MIMEMultipart:
          msg.attach(mime)

  # 发送邮件
  # stmp_server = None              ####### TODO
  stmp_server = "smtp.163.com"
  port = 25
  server = smtplib.SMTP(stmp_server, 25)
  server.set_debuglevel(1)
  server.login(from_addr, passwd)
  server.sendmail(from_addr, [to_addr], msg.as_string())

#+END_SRC
** Python2DSLAM

#+include: ~/Wally/Project/SLAM2dPython/README.md
#+include: ~/Wally/Project/SLAM2dPython/ChangeLog.txt

*** Unit_A: Robot,  motion model,  scan data
**** Motion model
***** 推导过程

[[~/Wally/Journal/Figure/scrot/154864nG.png]]

#+BEGIN_SRC latex
  \begin{displaymath}
    \left\{
      \begin{array}{l}
        r=\alpha(R+w) \\
        l=\alpha\cdot R
      \end{array}
    \right.
  \end{displaymath}


  \begin{displaymath}
    \left\{
      \begin{array}{l}
        \alpha=\frac{r-l}{w} \\
        R=\frac{l}{\alpha}
      \end{array}
    \right.
  \end{displaymath}
#+END_SRC

[[~/Wally/Journal/Figure/scrot/15486UFV.png]]

#+BEGIN_SRC latex
  \begin{displaymath}
    C=P-(R+\frac{w}{2})\cdot\left[
      \begin{array}{l}
        \sin\theta\\
        -\cos\theta
      \end{array}
    \right]
  \end{displaymath}
  \begin{displaymath}
    P'=C+(R+\frac{w}{2})\cdot\left[
      \begin{array}{l}
        \sin(\theta+\alpha)\\
        -\cos(\theta+\alpha)
      \end{array}
    \right]
  \end{displaymath}
  \begin{displaymath}
    \theta'=(\theta+\pi)\mod 2\pi
  \end{displaymath}
#+END_SRC

***** 问题模型

*Given*:
+ (x, y, \theta)
+ (l, r)
+ w
*For*
($x'$, $y'$, $\theta'$)

***** 求解

1. case 1: $l \ne r$
   1) $\alpha=\frac{r-l}{w}$
   2) $R=\frac{l}{\alpha}$
   3) $\left[\begin{array}{l}cx\\cy\end{array}\right]=\left[\begin{array}{l}x\\y\end{array}\right]-\left(R+\frac{w}{2}\right)\cdot\left[\begin{array}{l}\sin\theta\\-\cos\theta\end{array}\right]$
   4) $\theta'=(\theta+\alpha)\mod 2\pi$
   5) $\left[\begin{array}{l}x'\\y'\end{array}\right]=\left[\begin{array}{l}cx\\cy\end{array}\right]+\left(R+\frac{w}{2}\right)\cdot\left[\begin{array}{l}\sin\theta'\\-\cos\theta'\end{array}\right]$
2. case 2: l=r
   1) $\theta=\theta'$
   2) $x'=x+l\cdot\cos\theta$
   3) $y'=y+l\cdot\sin\theta$

***** 参数

+ w = 150mm
+ 1 tick = 0.349mm

***** 实现

#+BEGIN_SRC python
  from math import sin, cos, pi
  from pylab import *
  from lego_robot import *


  def filter_step(old_pose, motor_ticks):

      # Find out if there is a turn at all
      if motor_ticks[0] == motor_ticks[1]:
          # No turn. Just drive straight
          theta = old_pose[2]
          x = old_pose[0] + motor_ticks[0]*ticks_to_mm*cos(theta)
          y = old_pose[1] + motor_ticks[0]*ticks_to_mm*sin(theta)

          return (x, y, theta)

      else:
          # Turn. Computer alpha, R, etc.
          alpha = (motor_ticks[1]*ticks_to_mm - motor_ticks[0]*ticks_to_mm) \
                  / robot_width
          r = motor_ticks[0] / alpha

          cx = old_pose[0] - (r+robot_width/2)*sin(old_pose[2])
          cy = old_pose[1] + (r+robot_width/2)*cos(old_pose[2])
          theta = (old_pose[2] + alpha) % (2*pi)

          x = cx + (r+robot_width/2)*sin(theta)
          y = cy - (r+robot_width/2)*cos(theta)

          return (x, y, theta)


  if __name__ == '__main__':
      # Empirically derived conversion from ticks to mm
      ticks_to_mm = 0.349

      # Mesured width of the robot(wheel gauge), in mm
      robot_width = 150.0

      # Read data
      logfile = LegoLogfile()
      logfile.read("robot4_motors.txt")

      # start at origin (0,0), looking along x axis (alpha = 0)
      pose = (0.0, 0.0, 0.0)

      # Loop over all motor ticks records generate filtered position list
      filtered = []
      for ticks in logfile.motor_ticks:
          pose = filter_step(pose, ticks)
          filtered.append(pose)

      for pose in filtered:
          print pose
      plot([p[0] for p in filtered], [p[1] for p in filtered], 'bo')
      show()
#+END_SRC

**** Scan data
***** sensor data memory

#+BEGIN_EXAMPLE
S(flag) 315(timestamp) 660(count) 123 124(range data) ....
#+END_EXAMPLE

***** 计算微分

$f'(i)=\frac{f(i+1)-f(i-1)}{2}$

****** 伪代码

#+BEGIN_SRC latex
    \begin{algorithm}[ht]
      \textbf{ComputeDerivative(A, t)}\;

      \KwIn{A=[a1, a2, ... an]: array, t: threshold against outliers}
      \KwOut{D=[d1, d2, ... dn]: derivative at each element}

      D[1]=0 \tcp{头部边界}\;
      \For{{\color{red}{{i = 2 \KwTo A.length-1}}}}{
        \eIf{A[i-1] > t AND A[i+1] > t}{
          D[i]=(A[i+1]-A[i-1])/2
        }{
          D[i] = 0\tcp{异常点}
        }
      }
      D[n]=0\tcp{尾部边界}\;
      \Return{D}
    \end{algorithm}
#+END_SRC

****** python 实现

#+BEGIN_SRC sh
  def compute_derivative(scan, min_dist):
      jumps = [0]
      for i in xrange(1, len(scan)-1):
          l = scan[i-1]
          r = scan[i+1]
          if l > min_dist and r > min_dist:
              derivative = (r - l) / 2.0
              jumps.append(derivative)
          else:
              jumps.append(0)

      jumps.append(0)
      return jumps
#+END_SRC

***** 特征点提取

[[~/Wally/Journal/Figure/scrot/15486z1K.png]]

****** 定义与特征

圆柱
在扫描线上处于波谷中心，在微分曲线上表现为先上升尖后下降尖

****** 问题描述

+ 输入：扫描线
  - 数据结构：数组，每个元素对应一个距离
+ 输出：特征点位置
  - 数据结构：结构数组，每个元素为一个结构，结构中包含一组索引和距离信
    息

****** 算法描述

思想：取扫描线上升沿和下降沿之间的索引和距离数据均值

注意：
1. 特征点的重叠处理
2. 索引整数除法或者说需要取整

****** 伪代码

#+BEGIN_SRC latex
  \begin{algorithm}
    \textbf{FIND-CYLINDERS(scan, jump)}\;
    \KwIn{scan: 扫描线数组，每个元素对应一个距离信息, jump: 微分的跳动阈
      值}
    \KwOut{cylinders: 特征点结构数组，每个元素对应一个包含索引和距离
      的结构}
    oncylinder = FALSE\;
    ray = 0\;
    index = 0\tcp{索引和}
    depth = 0\tcp{距离和}
    cylinders=[]\;
    n = 0\tcp{特征点个数}
    derivate=COMPUTE-DERIVATIVES(scan)\;
    \For{i=1 \KwTo scan.length}{
      \If{derivative[i] < -jump\tcp{下降沿，开始计数}}{
        ray = 0
        index = 0
        depth = 0
        oncylinder = TRUE
      }
      \tcp{注意条件分支结构}
      \eIf{derivate[i] > jump AND oncylinder \tcp{上升沿，结束计数}}{
        n = n+1
        cylinders[i]=struct(index/ray, depth/ray)
      }{
        \If{scan[i] > mindist}{
          ray = ray+1
          index = index+i
          depth = depth+scan[i]
        }
      }
    }
    \Return{cylinders}
  \end{algorithm}
#+END_SRC

****** python实现

#+BEGIN_SRC python
  def find_cylinders(scan, scan_derivative, jump, min_dist):
      cylinder_list = []
      on_cylinder = False
      rays, sum_ray, sum_depth = 0, 0.0, 0.0

      for i in xrange(len(scan_derivative)):
          if scan_derivative[i] < -jump:
              rays, sum_ray, sum_depth = 0, 0.0, 0.0
              on_cylinder = True
          if on_cylinder:
              if scan_derivative[i] > jump:
                  cylinder_list.append((sum_ray/rays, sum_depth/rays))
                  on_cylinder = False
              elif scan[i] > min_dist:
                  rays += 1
                  sum_ray += i
                  sum_depth += scan[i]

      return cylinder_list
#+END_SRC

**** 阅读源码的思考

良好的源码有明确的目标需求和良好的结构层次。

所以阅读源码不应该直接逐行逐句来，遇到不会的地方就查，而是应该
1) 首先，把握目标 *明白程序实现的是什么功能* ， 同时去思考如果自己写，会怎
   么实现
2) 其次，立足整体， *理清楚程序的结构，并找出逻辑*
3) 先总后分， 分而治之，逐步求精， 阅读源码
4) 遇到拦路虎先不去管，只是记下来， *时刻明确自己在做什么* ， 不要顾及
   不重要的细节

**** logfile_viewer.py
***** 功能

1. GUI --> Tkinter
   + 主窗口
     - 传感器坐标(Canvas)
     - 世界坐标系(Canvas)
     - 其它控件
   + 事件响应
     - 加载文件(tkFileDialog)
     - 响应拖动(Scale)

2. 数据可视化
   1) 数据如何存储
   2) 可视化的方法怎样实现

***** 结构

1. 主函数中构建GUI界面
2. LegoLogfile保存并跟踪数据
3. 绘制不同数据使用不同的对象，这些对象有共同的基类（因为方法相似）

***** main

1. legologfile
2. tk & widgets
3. mainloop

***** 基类

1. DrawableObject
   - Trajectory : class
   - ScannerData : class
   - Landmarks : class
   - Points : class
   - Particles : class
2. Methods
   1) background_draw (self)
   2) draw (self,at_step)
      #+begin_latex
        \begin{minted}[frame=single, mathescape]{py}
            def draw(self, at_step):
                print "To be overwritten - will draw a certain point in time:", at_step

            def background_draw(self):
                print "Background draw."
        \end{minted}
      #+end_latex

      - 基类共同的方法为空
      - 默认 __init__方法
   3) get_ellipse_points (center,main_axis_angle,radius1,radius2,start_angle,end_angle)
      #+begin_latex
        \begin{minted}[frame=single, mathescape]{py}
            @staticmethod
            def get_ellipse_points(center, main_axis_angle, radius1, radius2,
                                   start_angle = 0.0, end_angle = 2 * pi):
                """Generate points of an ellipse, for drawing (y axis down)."""
                # ...
                return points
        \end{minted}
      #+end_latex
      - @staticmethod 定义静态方法
      - """""" 三引号函数说明
      - 参数与返回值

***** Trajectory

Trajectory : class
- Parents: DrawableObject
- __init__ (self,points,canvas,world_extents,canvas_extents,standard_deviations,point_size2,background_color,cursor_color,position_stddev_color,theta_stddev_color)
- background_draw (self)
- draw (self,at_step)

*** Unit_B: Landmark assignment, similarity transform,  Icp
- State "TOBECONTINED" from "TODO"       [2015-11-04 三 16:09]

**** simularity simularity
***** 模型
[[~/Wally/Journal/Figure/scrot/329789G.png]]

#+BEGIN_SRC latex
  \begin{displaymath}
    \lambda{}Rl_i+t=r_i
  \end{displaymath}

  $\lambda\in\mathbf{R}$ scale factor
  \[
  R=\left[
    \begin{array}{ll}
      \cos\alpha&-\sin\alpha\\
      \sin\alpha&\cos\alpha
    \end{array}
  \right]\in\mathbf{R}^{2\times{}2}
  \]
  $t=[t_X,t_y]^T\in\mathbf{R}^2$
#+END_SRC

4 parameters

#+begin_src latex
  \begin{displaymath}
    \lambda{}Rl_i+t=r_i
  \end{displaymath}
  \begin{displaymath}
    \sum_{i}\
lambda{}Rl_i+t-r_i\
  \end{displaymath}
#+end_src

Nonlinear -> Linearize and iterate.

***** 变换： compute center

[[~/Wally/Journal/Figure/scrot/3297d1U.png]]

#+begin_src latex
  \begin{displaymath}
    \bar{l}=\frac{1}{m}\sum_{i}l_i
  \end{displaymath}
  \[\bar{r}=\frac{1}{m}\sum_{i}l_i\]
  \[l_i'=l_i-\bar{l}\]
  \[r_i'=r_i-\bar{r}\]
  \[\sum_{i}l_i'=0\]
  \[\sum_i{}r_i'=0\]
#+end_src

#+begin_src latex
  \begin{align*}
    & \lambda{}Rl_i-r_i+t \\
  = & \lambda{}R(l_i'+\bar{l})-(r_i'+\bar{r})+t\\
  = & \lambda{}Rl_i'-r_i'+\underbrace{\lambda{}R\bar{l}-\bar{r}+t}_{t'}\\
  = & \lambda{}Rl_i'-r_i'-t'\rightarrow min
  \end{align*}
#+end_src

#+begin_src latex
  \begin{align}
    & \sum_{i}\|\lambda{}Rl_i'-r_i'+t'\|^2 \\
  = &
      \sum_{i}\|lambda{}Rl_i'-r_i'\|^2+2t'^T\underbrace{\sum_{i}(\lambda{}Rl_i'-r_i')}_{0}+\underbrace{\sum_{i}\|t'\|^2}_{m\cdot\|t'\|^2}
    \\
  = &
      \underbrace{\sum_{i}\|lambda{}Rl_i'-r_i'\|^2}_{\geqslant{}0}+\underbrace{m\cdot\|t'\|^2}_{\geqslant{}0}
      \rightarrow min
  \end{align}
#+end_src

#+begin_src latex
  \begin{eqnarray*}
    t'=0  \\
   \lambda{}R\bar{l}-\bar{r}+t=0 \\
\rightarrow t = \bar{r}-\lambda{}R\bar{l}
  \end{eqnarray*}
#+end_src

#+begin_src latex
  \begin{eqnarray*}
    \sum_{i}\|\lambda{}Rl_i'-r_i'\|^2\rightarrow min \\
    \sum_i\|sqrt{\lambda}Rl_i'-\frac{1}{\sqrt{\lambda}r_i'}\|^2\rightarrow min
  \end{eqnarray*}

  \begin{align*}
    &
      \sum_i\|sqrt{\lambda}Rl_i'-\frac{1}{\sqrt{\lambda}r_i'}\|^2 \\
  = &
      \lambda\underbrace{\sum_{i}\|Rl_i'\|^2}_{\sum_{i}\|l_i'\|^2}-2\sum_{i}r_i'^Tl_i'+\frac{1}{\lambda}\sum_{i}\|r_i'\|^2
    \\
  = & \lambda{}a+b+\frac{1}{\lambda}c\rightarrow min
  \end{align*}

  \begin{eqnarray*}
    \lambda^2=\frac{c}{a}=\frac{\sum_{i}\|r_i'\|^2}{\sum_i{\|l_i'\|^2}}\\
    \lambda=\sqrt{\frac{c}{a}=\frac{\sum_{i}\|r_i'\|^2}{\sum_i{\|l_i'\|^2}}}
  \end{eqnarray*}
#+end_src

#+begin_src latex
    \begin{eqnarray*}
      \sum_{i}r_i'^T\cdot R\cdot l_i' \rightarrow max \\
      \left[
      \begin{array}{ll}
        l_x&r_x
      \end{array}
  \right]\left[
      \begin{array}{ll}
        \cos\alpha & -\sin\alpha \\
        \sin\alpha & \cos\alpha
      \end{array}
      \right]
  \left[
                     \begin{array}{l}
                       l_x\\l_y
                     \end{array}
                     \right] \\
  \left[
      \begin{array}{ll}
        l_x&r_x
      \end{array}
  \right] \left[
      \begin{array}{l}
        l_x\cos\alpha -l_y\sin\alpha \\
        \_x\sin\alpha+l_y\cos\alpha
      \end{array}
      \right]\\
    r_xl_x\cos\alpha-r_xl_y\sin\alpha+r_y\l_x\sin\alpha+r_yl_y\cos\alpha\\
    \cos\alpha(r_xl_x+r_yl_y)+\sin\alpha(-r_xl_y+r_yl_x)
    \end{eqnarray*}

    \begin{align*}
      \sum_{i}r_i'^TRl_i'& = & \cos\alpha\cdot\sum_{i}(r_x'l_x'+r_y'l_y')+
                               \sin\alpha\sum_{i}(-r_x'l_y'+r_y'l_x')
                               \\
   &= &\left[
        \begin{array}{ll}
         \cos\alpha &\sin\alpha
        \end{array}
  \right]\left[
                      \begin{array}{l}
                        \sum_{i}(r_x'l_x'+r_y'l_y')\\
                        \sum_{i}(-r_x'l_y'+r_y'l_x')
                      \end{array}
  \right]
    \end{align*}
    \begin{displaymath}
      \left[
        \begin{array}{l}
          \cos\alpha\\\sin\alpha
        \end{array}
  \right]=\frac{1}{\|\cdot\|}\left[
    \begin{array}{l}
      \sum_{i}(r_x'l_x'+r_y'l_y')\\
      \sum_{i}(-r_x'l_y'+r_y'l_x')
    \end{array}
  \right]
    \end{displaymath}
#+end_src

****** Recipe

+ Given: l_i,  r_i
+ Compute: $\bar{l}=\frac{1}{m}\sum{}l_{i}$,
  $\bar{r}=\frac{1}{m}\sum{}r_{i}$
  $l_{i}'=l_{i}-\bar{l}$, $r_{i}'=r_{i}-\bar{r}$


cs, ss, rr, ll = 0.0
for i in 1...m:
    $cs+=r_{x}'l_{x}'+r_{y}'l_{y'}$
    $ss+=-r_{x}'l_{y}'+r_{y}'l_{x}'$
    $rr+=r_{x}'r_{x}'+r_{y}'r_{y}'$
    $ll+=l_{x}'l_{x}'+l_{y}'l_{y}'$
$\lambda=\sqrt{\frac{rr}{ll}}$

#+begin_src latex
  \begin{displaymath}
    \left[
      \begin{array}{l}
        c\\s
      \end{array}
  \right]=\left[
    \begin{array}{l}
      cs\\ss
    \end{array}
  \right]/\sqrt{cs^2+ss^2}
  \end{displaymath}

  \begin{displaymath}
    \left[
      \begin{array}{l}
        t_x\\t_y
      \end{array}
  \right]=\bar{r}-\lambda{}R\bar{l}=\left[
    \begin{array}{l}
      \bar{r_x}\\\bar{r_y}
    \end{array}
  \right]-\lambda\left[
    \begin{array}{ll}
      c&-s\\s&c
    \end{array}
  \right]\left[
    \begin{array}{l}
      \bar{l_x}\\\bar{l_y}
    \end{array}
  \right]
  \end{displaymath}
  \begin{displaymath}
    (\lambda, c, s, t_x, t_y)
  \end{displaymath}
#+end_src

*** lego_robot.py

1. int & tuple
   #+BEGIN_SRC python
     p = (int(sp[2]), int([sp[3]]))  # position as a tuple'
   #+END_SRC

2. map
   #+BEGIN_SRC python
   map(int, sp[2:])
   #+END_SRC

** NEXT TimBailey
:LOGBOOK:
- State "NEXT"       from "NEXT"       [2016-02-29 一 21:09] \\
  简单地调试了下整个 SLAM 仿真，对基本流程有了比较清楚的认识，尽管这件事
  情早就应该完成。没有纠结于细节部分，这样很好。
- State "NEXT"       from "NEXT"       [2016-02-29 一 10:27] \\
  重新对运动和测量进行建模，接下来完成方程的线性化处理
- State "NEXT"       from "TODO"       [2016-02-26 五 21:40] \\
  非常愚蠢地葬送了半天多的辛苦
- State "TODO"       from ""           [2016-02-26 五 10:24] \\
  开始系统认真地研究 SLAM 算法，TimBailey 的 Matlab 仿真应该在本周剩余的
  三天内完成。
:END:

#+include: ~/Wally/Project/TimBailey

*** README

*** ChangeLog
*** reference

- [[http://www-personal.acfr.usyd.edu.au/tbailey/][Tim Bailey's homepage]]
- [[~/Wally/Project/TimBailey/bailey2003constrained.pdf]]
- [[~/Wally/Project/TimBailey/bailey2006consistency2.pdf]]
- [[~/Wally/Project/TimBailey/exercise_ekf_slam.pdf]]
- [[~/Wally/Project/TimBailey/nieto2007recursive.pdf]]
- [[~/Wally/Project/TimBailey/bailey2006consistency.pdf]]
- [[~/Wally/Project/TimBailey/dissanayake2000computationally.pdf]]
- [[~/Wally/Project/TimBailey/nieto2006scan.pdf]]

*** ekfslam

#+include: ~/Wally/Project/TimBailey/ekfslam_v1.0

- 状态向量 :: $\mathbf{x}_{k}=[x_{k}, y_{k}, \phi_{k}]^{T}$
- 控制向量 :: $\mathbf{u}_k=[v_k, \gamma_k]^T$
- 位置微量 :: \[\mathbf{z}_{k}=[r_{k}, \theta_{k}]^{T}\]


**** 建模
***** 运动学模型

[[/home/wally/Wally/Journal/Figure/scrot/20137zF.png]]

*问题表述*

已知， \[\mathbf{x}_{k-1}\], \[\mathbf{u}_{k}\] 求 \[\mathbf{x}_{k}\]

*运动微分方程*  参见 [[~/Wally/Reference/Textbook/PlanningAlgoritms.pdf][PlanningAlgoritms.pdf]] 13.1.2.1

\[\dot{x}=f_{1}(x, y, \phi, v, \gamma)\]
\[\dot{y}=f_{2}(x, y, \phi, v, \gamma)\]
\[\dot{\phi}=f_{3}(x, y, \phi, v, \gamma)\]

模型原点： 前轴中心
运动轨迹： 圆弧，其圆心为后轴与 \[\mathbf{v}_{k}\] 垂线的交点, 半径为 \[\rho=B/\sin(\gamma)\]

在小量时间 \[\Delta{}t\] 内，参考点沿 \[v_{k}\] 方向运动，因此有
\[\mathrm{d}y/\mathrm{d}x=\tan(\gamma+\phi)\]
\[-\mathrm{dx}\sin(\gamma+\phi)+\mathrm{d}y\cos(\gamma+\phi)=0\]
\[\dot{x}=v\cos(\gamma+\phi)\]
\[\dot{y}=v\sin(\gamma+\phi)\]

设小量时间内，参考点前进距离为 l, 则有
\[\mathrm{d}l=\rho{}\mathrm{d}\phi\]
\[v=B/\sin(\gamma)\dot{\phi}\]
\[\dot{\phi}=\frac{v\sin(\gamma)}{B}\]

*离散差分方程*

\begin{displaymath}
\mathbf{x}_{k}=
\left[
\begin{array}{l}
x_{k}\\
y_{k}\\
\phi_{k}
\end{array}
\right]
=\mathbf{f}(\mathbf{x}_{k-1}, \mathbf{u}_k)=
\left[
\begin{array}{l}
x_{k-1}+v_{k}\cos(\gamma+\phi)\Delta{}t\\
y_{k-1}+v_{k}\sin(\gamma+\phi)\Delta{}t\\
\phi_{k-1}+\frac{v_{k}\sin(\gamma)}{B}\Delta{}t
\end{array}
\right]
\end{displaymath}

***** 过程噪声

控制向量的过程噪声，即 v 和 \[\gamma\] 的测量噪声

\[p(\mathbf{w})\sim{}N(0, \mathbf{Q})\]

其中，过程激励协方差矩阵 \[\mathbf{Q}\] 随时间迭代改变，这里假设为常数

\begin{displaymath}
\mathbf{Q}=
\left[
\begin{array}{cc}
\sigma^{2}(v) & 0\\
0 & \sigma^{2}(\gamma)
\end{array}
\right]
\end{displaymath}

***** 激光传感器模型

[[/home/wally/Wally/Journal/Figure/scrot/2013xlg.png]]


\begin{displaymath}
\mathbf{z}_{k}^{(i)}=
\left[
\begin{array}{l}
r_{k}\\
\theta_{k}
\end{array}
\right]
=
\mathbf{h}(\mathbf{x}_k)=
\left[
\begin{array}{c}
\sqrt{(y_{i}-y_{k})^{2}+(x_{i}-x_{k})^{2}}\\
\arctan(\frac{y_{i}-y_{k}}{x_{i}-x_{k}})-\phi_{k}
\end{array}
\right]
\end{displaymath}

***** 量测噪声

量测噪声是量测向量 \[\mathbf{z}_{k}\] 的噪声

\[\mathbf{p}(\upsilon)\sim{}N(0, R)\]

\begin{displaymath}
\mathbf{R}=
\left[
\begin{array}{ll}
\sigma^{2}(r) & 0\\
0 & \sigma^{2}(\theta)
\end{array}
\right]
\end{displaymath}

也假设为常数。

***** 线性化

将期望和方差线性化的卡尔曼滤波器称作扩展卡尔曼滤波器（Extended Kalman
Filter），简称 *EKF*

线性化的思想：
最基本的近似方法是泰勒近似法,其思路是:当状态的先验分布可用高斯分布近似
时,状态的条件分布完全由其均值和协方差阵表征,若在状态的滤波值和预测值周
围分别将状态转移方程和观测方程进行泰勒展开

****** general

参考： [[~/Wally/Reference/Guide/AnInroductionToTheKalmanFilter.pdf][AnInroductionToTheKalmanFilter_EN.pdf]] （不是文献）

# 春朋的论文中提及了 KF 和 EKF 的推导
# 写公式时要考虑 LaTeX 公式的复用，注意为行内公式还是单行公式，注意字
# 母选择，以及上/下标、粗体/正常的规范

\[\mathbf{x}_{k}=\mathbf{f}(\mathbf{x}_{k-1},\mathbf{u}_{k},\omega_{k})\]
\[\mathbf{z}_{k}=\mathbf{h}(\mathbf{z}_{k-1}, \upsilon_{k})\]

估计值
\[\tilde{\mathbf{x}}_{k}=\mathbf{f}(\hat{\mathbf{x}}_{k-1}, \mathbf{u}_{k}, \mathbf{0})\]
\[\tilde{\mathbf{z}}_{k}=\mathbf{h}(\tilde{\mathbf{x}}_{k-1},
\mathbf{0})\]

\[\tilde{\mathbf{x}}_{k}\] 先验
\[\hat{\mathbf{x}}_{k}\] 后验
\[\mathbf{x}_{k}\] 真值

非线性差分方程的线性表示

\[\mathbf{x}_{k}=\tilde{\mathbf{x}}_{k}+\mathbf{A}(\mathbf{x}_{k-1}-\hat{\mathbf{x}}_{k-1})+\mathbf{W}\mathbf{\omega}_{k-1}\]
\[\mathbf{z}_{k}=\tilde{\mathbf{z}}_{k}+\mathbf{H}(\mathbf{x}_{k}-\tilde{\mathbf{x}}_{k})+\mathbf{V}\mathbf{\upsilon}_{k}\]

\[\mathbf{A}, \mathbf{W}, \mathbf{H}, \mathbf{V}\] 为微分方程对对应参
数的雅可比矩阵

\begin{displaymath}
A_{[i, j]}=\frac{\partial{}f_{[i]}}{\partial{}x_{[j]}}(\hat{\mathbf{x}_{k-1}}, \mathbf{u}_{k-1}, 0)
\end{displaymath}


\begin{displaymath}
W_{[i, j]}=\frac{\partial{}f_{[i]}}{\partial{}\omega_{[j]}}(\hat{\mathbf{x}_{k-1}}, \mathbf{u}_{k-1}, 0)
\end{displaymath}

\begin{displaymath}
H_{[i, y]}=\frac{\partial{}h_{[i]}}{\partial{}x_{[j]}}(\tilde{x}_{k}, 0)
\end{displaymath}

\begin{displaymath}
V_{[i, j]}=\frac{\partial{}h_{[i]}}{\partial{}\upsilon_{k}}(\tilde{x}_{k}, 0)
\end{displaymath}

根据差分方程（而不是微分方程求 Jabobian 矩阵）在迭代时使用。

****** 运动模型

\[\phi\] 和 \[\gamma\] 缺少下标

\begin{displaymath}
\mathbf{x}_{k}=
\left[
\begin{array}{l}
x_{k}\\
y_{k}\\
\phi_{k}
\end{array}
\right]
=\mathbf{f}(\mathbf{x}_{k-1}, \mathbf{u}_k)=
\left[
\begin{array}{l}
x_{k-1}+v_{k}\cos(\gamma+\phi)\Delta{}t\\
y_{k-1}+v_{k}\sin(\gamma+\phi)\Delta{}t\\
\phi_{k-1}+\frac{v_{k}\sin(\gamma)}{B}\Delta{}t
\end{array}
\right]
\end{displaymath}

\begin{displaymath}
\mathbf{G}_{v}=
\left[
\begin{array}{lll}
1 & 0 & -v_{k}\Delta{}t\sin(\gamma+\phi) \\
0 & 1 & v_{k}\Delta{}t\cos(\gamma+\phi) \\
0 & 0 & 1
\end{array}
\right]
\end{displaymath}

\begin{displaymath}
\mathbf{G}_{v}=
\left[
\begin{array}{ll}
\Delta{}t\cos(\gamma+\phi_{k-1})  & -v_{k}\Delta{}t\sin(\gamma+\phi_{k-1}) \\
\Delta{}t\sin{\gamma+\phi_{k-1}}  & v_{k}\Delta{}t\cos(\gamma+\phi_{k-1})\\
\frac{\Delta{}t\sin(\gamma)}{B} & \frac{v_{k}\Delta{}t\cos(\gamma)}{B}
\end{array}
\right]
\end{displaymath}

****** 量测模型

\begin{displaymath}
\mathbf{z}_{k}^{(i)}=
\left[
\begin{array}{l}
r_{k}\\
\theta_{k}
\end{array}
\right]
=
\mathbf{h}(\mathbf{x}_k)=
\left[
\begin{array}{c}
\sqrt{(y_{i}-y_{k})^{2}+(x_{i}-x_{k})^{2}}\\
\arctan(\frac{y_{i}-y_{k}}{x_{i}-x_{k}})-\phi_{k}
\end{array}
\right]
\end{displaymath}

**** EKF

***** general

****** 时间更新（预测）

\begin{displaymath}
\mathbf{x}_{k}^{-}=\mathbf{f}(\hat{\mathbf{x}}^{k-1}, \mathbf{u}_{k}, \mathbf{0})
\end{displaymath}

\begin{displaymath}
P_{k}^{-}=A_{k}P_{k-1}A_{k}^{T}+W_{k}Q_{k-1}W_{k-1}^{t}
\end{displaymath}

****** 状态更新

\begin{displaymath}
K_{k}=P_{k}^{-}H_{k}^{T}(H_{k}P_{k}^{-}H_{k}^{T}+V_{k}R_{k}V_{k}^{T})^{-1}
\end{displaymath}

\begin{displaymath}
\hat{\mathbf{x}}_{k}=\mathbf{x}_{k}^{-}+K_{k}(\mathbf{x}_{k}^{-}-h(\mathbf{x}_{k}^{-}, 0))
\end{displaymath}

\begin{displaymath}
P_{k}=(I-K_{k}H_{k})P_{k}^{-}
\end{displaymath}

***** 预测

Besides updating the position of the robot in the state vector. We
also want to update the uncertainty of the estimated position of the
robot and the estimated positions of the landmarks.

#+BEGIN_SRC octave
  % predict covariance
  P(1:3,1:3)= Gv*P(1:3,1:3)*Gv' + Gu*Q*Gu';
  if size(P,1)>3
      P(1:3,4:end)= Gv*P(1:3,4:end);
      P(4:end,1:3)= P(1:3,4:end)';
  end
#+END_SRC

In the first line, the uncertainty of the robot’s xy-position and
orientation is updated. In the next four lines, the uncertainty of the
relation between the robot and all the landmarks in the map are
updated.

？？？

***** TODO 更新

**** TODO 数据关联与更新

#+BEGIN_SRC octave
  % data association innovation gates (Mahalanobis distances)
  GATE_REJECT= 4.0; % maximum distance for association
  GATE_AUGMENT= 25.0; % minimum distance for creation of new feature
  % For 2-D observation:
  %   - common gates are: 1-sigma (1.0), 2-sigma (4.0), 3-sigma (9.0), 4-sigma (16.0)
  %   - percent probability mass is: 1-sigma bounds 40%, 2-sigma 86%, 3-sigma 99%, 4-sigma 99.9%.
#+END_SRC

**** TODO 惯导在二维下的运动模型推导
*** fastslam

**** PF 推导

***** Reference

****** [[~/Wally/GraduationProject/Literature/arulampalam2002tutorial.pdf][arulampalam2002tutorial]]
:BIBTEX:
@article{arulampalam2002tutorial,
  title={A tutorial on particle filters for online nonlinear/non-Gaussian Bayesian tracking},
  author={Arulampalam, M Sanjeev and Maskell, Simon and Gordon, Neil and Clapp, Tim},
  journal={Signal Processing, IEEE Transactions on},
  volume={50},
  number={2},
  pages={174--188},
  year={2002},
  publisher={IEEE}
}
:END:

****** [[~/Wally/GraduationProject/Literature/chenbayesian.pdf.crdownload][chenbayesian]]
:BIBTEX:
@misc{chenbayesian,
  title={Bayesian filtering: from kalman filters to particle filters, and beyond, Adaptive Syst. Lab., McMaster Univ., Hamilton, ON, Canada, 2003},
  author={Chen, Zhe}
}
:END:

****** [[~/Wally/Reference/Guide/TutorialOnMonteCarloTechniques.pdf][TutorialOnMonteCarloTechniques.pdf]]                  :monter_carlo:

****** [[~/Wally/GraduationProject/Literature/hol2006resampling.pdf][hol2006resampling]]
:BIBTEX:
@inproceedings{hol2006resampling,
  title={On resampling algorithms for particle filters},
  author={Hol, Jeroen D and Schon, Thomas B and Gustafsson, Fredrik},
  booktitle={Nonlinear Statistical Signal Processing Workshop, 2006 IEEE},
  pages={79--82},
  year={2006},
  organization={IEEE}
}
:END:

****** [[~/Wally/Reference/Guide/粒子滤波理论.pdf][粒子滤波理论.pdf]]                                :particle_filter:
*** ukfslam
** NEXT imutoolbox
:LOGBOOK:
- State "NEXT"       from "TODO"       [2016-03-07 一 10:47] \\
  整理了参考资料
- State "TODO"       from ""           [2016-03-07 一 10:04] \\
  开始认真研习惯性导航, 目标:
  1. 理解 SINS, 以及其不同解法
  2. 完成论文的惯性测量单元部分
  3. 使用 Gazebo 做基本的仿真

  预计时间: 2天
:END:
:README:
*Readme for IMU toolbox*

matlab simulation for sins
:END:
:CHANGELOG:
- 2016/03/07  项目初始化
:END:

#+include: ~/Wally/Project/imutb

*** Reference

- [[~/Wally/Project/imutb/doc/INSToolbox.pdf][INSToolbox.pdf]]
- [[~/Wally/Reference/Textbook/捷联惯性导航技术_Zh_2nd.pdf][捷联惯性导航技术_Zh_2nd.pdf]]

*** elua to dcm


**** 捷联姿态表达

*姿态* : 载体坐标系相对于参考坐标系的表示

1. 方向余弦
2. 欧拉角
3. 四元数

**** DCM(Direct )

[[~/Wally/Reference/Wikipedia/方向余弦.pdf][方向余弦.pdf]]

***** 方向余弦

向量的方向余弦是指这个向量与三个坐标轴之间的角度的余弦.

\[\mathbf{\vec{v}}=[v_{x}, v_{y},
v_{z}]^{T}=v_{x}\mathbf{\vec{x}}+v_{y}\mathbf{\vec{y}}+v_{z}\mathbf{\vec{z}}\]

方向余弦

\[\mathbf{p}=[\alpha, \beta, \gamma]^{T}\]

\[\alpha=\cos(a)=\frac{\mathbf{\vec{v}}\cdot{}\mathbf{\vec{\mathbf{x}}}}{||\mathbf{\vec{v}}||}
=\frac{v_{x}}{\sqrt{v_{x_{2}}+v_{y}^{2}+v_{z}^{2}}}\]

\[\beta=\cos(b)=\frac{\mathbf{\vec{v}}\cdot{}\mathbf{\vec{\mathbf{y}}}}{||\mathbf{\vec{v}}||}
=\frac{v_{z}}{\sqrt{v_{x_{2}}+v_{y}^{2}+v_{z}^{2}}}\]

\[\gamma=\cos(c)=\frac{\mathbf{\vec{v}}\cdot{}\mathbf{\vec{\mathbf{z}}}}{||\mathbf{\vec{v}}||}
=\frac{v_{z}}{\sqrt{v_{x_{2}}+v_{y}^{2}+v_{z}^{2}}}\]

性质 \[\alpha^{2}+\beta^{2}+\gamma^{2}=1\]

两个向量之间的方向余弦指的是这两个向量之间的角度的余弦.

*方向余弦矩阵* 是由两组不同的标准正交基的基底向量之间的方向余弦所形成
的矩阵。
方向余弦矩阵可以用来表达一组标准正交基与另一组标准正交基之间的关系，也
可以用来表达一个向量对于另一组标准正交基的方向余弦。

***** 方向余弦矩阵

方向余弦方法可以用来设定附体参考系B的取向，即刚体的取
向。假设沿着参考系S的坐标轴的三个单位向量分别为 \[\vec{\mathbf{x}}_{1}\]、\[\vec{\mathbf{x}}_{}\]
、\[\vec{\mathbf{x}}_{3}\] ，沿着参考系B的坐标轴的三个单位向量分别为 \[\vec{\mathbf{e}}_{1}\]、\[\vec{\mathbf{e}}_{2}\]
、\[\vec{\mathbf{e}}_{3}\] 。定义 \[\vec{\mathbf{e}}_{i}\] 与
\[\vec{\mathbf{x}}_{j}\]之间的方向余弦 \[a_{ij}\] 为

\[a_{ij}=\cos(\theta_{ij})=\vec{\mathbf{e}}_{i}\cdot\vec{\mathbf{x}}_{j}\]

方向余弦矩阵

\[\mathbf{C}=[a_{ij}]\]

\begin{displaymath}
[\vec{\mathbf{e}}_{1}, \vec{\mathbf{e}}_{2}, \vec{\mathbf{e}}_{3}]=
\left[
\begin{array}{lll}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{array}
\right]
\cdot{}[\vec{\mathbf{x}}_1, \vec{\mathbf{x}}_2, \vec{\mathbf{x}}_3]
\end{displaymath}

***** 位姿

通常，整个刚体的空间位形可以简易地以以下参数设定：

1. 刚体的“位置”：

   挑选刚体内部一点G来代表整个刚体，通常会设定物体的质心或形心为这一点。
   从空间参考系S观测，点G的位置就是整个刚体在空间的位置。表示位置可以
   应用向量的概念。向量的起点为参考系S的原点，终点为点G。设定刚体的位
   置需要三个坐标，例如，采用直角坐标系，这三个坐标为x-坐标、y-坐标、
   z-坐标。这用掉了三个自由度。

2. 刚体的取向：

   描述刚体取向的方法有好几种，包括方向余弦、欧拉角、四元数等等。这些
   方法设定一个附体参考系B的取向（相对于空间参考系S）。附体参考系是固
   定于刚体的参考系。相对于刚体，附体参考系的取向固定不变。由于刚体可
   能会呈加速度运动，所以附体参考系可能不是惯性参考系。空间参考系是某
   设定惯性参考系，例如，在观测飞机的飞行运动时，附着于飞机场控制塔的
   参考系可以设定为空间参考系，而附着于飞机的参考系则可设定为附体参考
   系。刚体的取向需要用到另外三个自由度。

**** Euler angles

- [[~/Wally/Reference/Wikipedia/欧拉角.pdf][欧拉角.pdf]]
- [[~/Wally/Reference/Wikipedia/%E6%AC%A7%E6%8B%89%E8%A7%92_En.pdf][欧拉角_en.pdf]]

*经典欧拉角* 与 *泰特-布莱恩角* (航空航天工程)的不同

*Tait-Bryan angles*, following z-y’-x″ (intrinsic rotations)
convention, are also known as *nautical angles*, because they can be
used to describe the orientation of a ship or aircraft, or Cardan
angles, after the Italian mathematician and physicist Gerolamo
Cardano, who first described in detail the Cardan suspension and the
Cardan joint. They are also called *heading*, *elevation* and *bank*,
or *yaw*, *pitch* and *roll*. Notice that the second set of terms is
also usedfor the three aircraft principal axes.

从参考坐标系到一个新的坐标系的变换过程可以表示为
1. 绕参考坐标系的 z 轴 转动 \[\psi\]  (yaw, 偏航)
2. 绕新坐标系的 y 轴转动 \[\theta\]   (pitch, 俯仰)
3. 绕新坐标系的 x 轴转动 \[\phi\]  (roll, 橫滚)

**** 转换

[[/home/wally/Wally/Journal/Figure/scrot/2595ujz.png]]

证明

#+BEGIN_EXAMPLE
  C1 = [cpsi  spsi 0; ...
        -spsi cpsi 0; ...
         0     0   1];
  C2 = [cthe  0  -sthe; ...
          0   1     0 ; ...
        sthe  0   cthe];
  C3 = [1   0    0;   ...
        0  cphi sphi; ...
        0 -sphi cphi];

  DCMnb = C3 * C2 * C1;
#+END_EXAMPLE

**** matlab code
:CODE:
#+BEGIN_SRC matlab
  function DCMnb = eulr2dcm(eul_vect)
  %EULR2DCM       Euler angle vector to direction cosine
  %               matrix conversion.
  %
  %       DCMnb = eulr2dcm(eul_vect)
  %
  %   INPUTS
  %       eul_vect(1) = roll angle in radians
  %
  %       eul_vect(2) = pitch angle in radians
  %
  %       eul_vect(3) = yaw angle in radians
  %
  %   OUTPUTS
  %       DCMnb = 3x3 direction cosine matrix providing the
  %             transformation from the navigation frame
  %             to the body frame
  %

  %   REFERENCE:  Titterton, D. and J. Weston, STRAPDOWN
  %               INERTIAL NAVIGATION TECHNOLOGY, Peter
  %               Peregrinus Ltd. on behalf of the Institution
  %               of Electrical Engineers, London, 1997.
  %
  %       M. & S. Braasch 12-97
  %       Copyright (c) 1997 by GPSoft
  %       All Rights Reserved.
  %

    if nargin<1,error('insufficient number of input arguments'),end

    phi = eul_vect(1); theta = eul_vect(2); psi = eul_vect(3);

    cpsi = cos(psi); spsi = sin(psi);
    cthe = cos(theta); sthe = sin(theta);
    cphi = cos(phi); sphi = sin(phi);

    C1 = [cpsi  spsi 0; ...
          -spsi cpsi 0; ...
           0     0   1];
    C2 = [cthe  0  -sthe; ...
            0   1     0 ; ...
          sthe  0   cthe];
    C3 = [1   0    0;   ...
          0  cphi sphi; ...
          0 -sphi cphi];

    DCMnb = C3 * C2 * C1;
#+END_SRC
:END:

***** nargin

*** genpath

**** 为何转置

#+include: ~/Wally/Project/imutb/src/propitch.m  :lines "56"

*** 坐标系

**** 惯性坐标系——Inertial Frame(I-frame)

惯性坐标系是一个以地心为坐标原点，北极轴线方向为 z 轴的笛卡儿坐标系。x
轴和 y 轴位于赤道平面。但是它们并不旋转，而是依据太阳和星系来定位。在
某些书里惯性坐标系就简单的以字母“ i”来表示。

**** 地球坐标系——Earth Frame(E-frame)

地球坐标系原点为地球中心， x 轴穿过地心及赤道和零子午线的交点， z 轴指
向北极。在某些书里地球坐标系以字母“ e”表示。

**** 载体坐标系——Body Frame（ b 系）

载体坐标系原点为载体之质心， X 轴指向载体前端， Y 轴沿载体的纵轴方向，
Z 轴指向载体纵轴的右侧。绕这些轴正转会分别产生正滚动、俯仰和偏航。

**** 导航坐标系——Navigation Frame（ n 系）
民
导航坐标系是以载体为中心的笛卡儿坐标系，但并不固定在载体内。 x 轴和 y
轴通常在本地飞机里， z 轴沿本地垂直方向。 x 轴和 y 轴的确切方向取决于
要求的惯性机械运算法则。在 north-slaved 一例中， x 轴指北， y 轴指东。
通常称此为东北下（ NED）。另外，注意载体坐标系有时记为 nav-frame，有些
文章里记为‘ N’或‘ n’。

**** 本地坐标系——Local-Level Frame（ L 系）

本地系和导航系基本相同，只是导航系指北东地，而本地系指东北天。有时记
为 ENU。另外，注意本地系有时简记为‘ L’或‘ l’。

*** 加速度

:CODE:
gendv.m
#+BEGIN_SRC matlab
function deltav_b = gendv(vel_prof_L,DCMnb_prof)
%GENDV		Generate that component of the Delta-V corresponding
%           to earth-referenced velocity changes.  Coriolis and
%           gravity components are not computed here
%           (see GENDVCOR)
%
%	deltav_b = gendv(vel_prof_L,DCMnb_prof)
%
%   INPUTS
%       vel_prof_L = velocity profile over time
%          vel_prof(i,1:3) = elements of the i-th velocity vector
%                            in local-level frame (ENU if north slave)
%
%       DCMnb_prof = profile of direction cosine elements over time
%          DCMnb_prof(i,1:9) = elements of the i-th direction cosine matrix
%                            (DCM) for vehicle attitude (navigation-to-
%                            body); 1 = DCM(1,1),
%                            2 = DCM(1,2), 3 = DCM(1,3),
%                            4 = DCM(2,1), et cetera
%
%   OUTPUTS
%       deltav_b = profile of delta-V's in body frame (Nose-Rt.Wing-Down)
%

%	M. & S. Braasch 1-98
%	Copyright (c) 1998 by GPSoft
%	All Rights Reserved.
%

if nargin<1,error('insufficient number of input arguments'),end

C = [0 1 0; 1 0 0; 0 0 -1];
deltv_L = diff(vel_prof_L);
for k = 2:size(DCMnb_prof,1),
   dcmnb=[DCMnb_prof(k,1:3); DCMnb_prof(k,4:6); DCMnb_prof(k,7:9)];
   deltav_b(k-1,1:3) = ( dcmnb*(C*deltv_L(k-1,1:3)') )';
end

#+END_SRC
:END:

向量映射 L(NED) -> N(ENU)

\[r^{l}\rightarrow{}r^{n}\]

\[r^{n}=C_{l}^{n}r^{l}\]

即求 $C_{l}^{n}$ 从参考坐标系N(上标为参考)到目标坐标系L的变换。

\[\psi=-\pi/2\]
\[\theta=\pi\]
\[\phi=0\]

\begin{equation}
\label{Cln$}
C_{l}^{n}=C_{3}C_{2}C_{1}= \left[
\begin{array}{lll}
1 & 0 & 0 \\
0 & \cos(\phi) & \sin(\phi) \\
0 & -\sin(\phi) & \cos(\phi)
\end{array}
\right]
\left[
\begin{array}{lll}
\cos(\theta) & 0 & -\sin(\theta) \\
0 & 1 & 0 \\
\sin(\theta) & 0 & \cos(\theta)
\end{array}
\right]
\left[
\begin{array}{lll}
\cos(\psi) & \sin(\psi) & 0 \\
-\sin(\psi) & \cos(\psi) & 0 \\
0 & 0 & 1
\end{array}
\right]=
\left[
\begin{array}{lll}
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & -1
\end{array}
\right]
\end{equation}


即 NED 中的向量向 ENU 中的映射。

*** DONE 角速度
:LOGBOOK:
- State "DONE"       from "TCB"        [2016-03-11 五 14:46] \\
  看了下面的部分，明白了其物理意义
  所以遇到实在不明白的东西不要纠结过久，先看看别的，没有就找到启发了
- State "TCB"        from ""           [2016-03-11 五 14:41] \\
  理解了陀螺仪的输出是什么，但不明白为何要减去一个单位矩阵
:END:

:CODE:
#+BEGIN_SRC matlab
function deltheta = gendthet(DCMnb_prof)
%GENDTHET      Delta-theta generator.  Local-level components
%              only.  Earth-rate and craft-rate components
%              not calculated (see EARTHROT and CRAFRATE)
%
%	deltheta = gendthet(DCMnb_prof)
%
%   INPUTS
%       DCMnb_prof = profile of direction cosine elements over time
%                    relating nav-frame to the body-frame
%          DCMnb_prof(i,1:9) = elements of the i-th direction cosine matrix
%                            (DCM) for vehicle attitude; 1 = DCM(1,1),
%                            2 = DCM(1,2), 3 = DCM(1,3),
%                            4 = DCM(2,1), et cetera
%
%
%   OUTPUTS
%       deltheta = profile of three orthogonal gyro outputs (body
%                  motion only) over time; for the i-th flight path
%                  segment, deltheta(i,1) = x-gyro output (nose positive),
%                  deltheta(i,2) = y-gyro output (right wing positive),
%                  deltheta(i,3) = z-gyro output (down positive)
%

%   REFERENCE:  Titterton, D. and J. Weston, STRAPDOWN
%               INERTIAL NAVIGATION TECHNOLOGY, Peter
%               Peregrinus Ltd. on behalf of the Institution
%               of Electrical Engineers, London, 1997, pp. 42-43.
%
%	M. & S. Braasch 1-98
%	Copyright (c) 1997-98 by GPSoft
%	All Rights Reserved.
%

if nargin<1,error('insufficient number of input arguments'),end

for k = 2:size(DCMnb_prof,1),
  dcmnb2=[DCMnb_prof(k,1:3); DCMnb_prof(k,4:6); DCMnb_prof(k,7:9)];
  dcmnb1=[DCMnb_prof(k-1,1:3); DCMnb_prof(k-1,4:6); DCMnb_prof(k-1,7:9)];
  del_PSI = dcmnb1 * dcmnb2' - eye(3);
  deltapsi(k-1,1) = del_PSI(2,1);
  deltathe(k-1,1) = del_PSI(1,3);
  deltaphi(k-1,1) = del_PSI(3,2);
end
deltheta = [deltaphi deltathe deltapsi];
#+END_SRC
:END:

#+BEGIN_EXAMPLE
del_PSI = dcmnb1 * dcmnb2' - eye(3);
#+END_EXAMPLE

Q: 捷联陀螺仪的输出的角速度是相对哪个坐标系？ N系还是B系？
A: 根据图3-9/10/11，可以看出是相对于B系

Q: dcmnb1*dcmnb2' 表示 $C^{b_{1}}_{b_{2}}$, 即相对 b1 参考系 b2 的方向
余弦矩阵(映射)，根据 P28 的小角度推测，接下来的三个 delta 对应 一致，
但为什么要送去单位矩阵，尽管并不影响结果？del_PSI 的物理意义是什么？

\begin{equation}
\label{skewsymm}
\left[
\begin{array}{lll}
0 & -\psi & \theta \\
\psi & 0 & -\phi \\
-\theta & \phi & 0
\end{array}
\right]
\end{equation}

A: 表示斜对称阵

*** 方向余弦算法

方向余弦矩阵随时间的变化 (详细推导见 C3.6.2.3)

\begin{equation}
\label{delta-dcm}
\dot{\mathbf{C}_{b}^{n}}=\mathbf{C}_{b}^{n}\mathbf{\Omega_{nb}^{b}}
\end{equation}

\begin{equation}
\label{symmetric}
\mathbf{\Omega}_{nb}^{b}=
\left[
\begin{array}{ccc}
0 & -\omega_{z} & \omega_{y} \\
\omega_{z} & 0 & -\omega_{x} \\
-\omega_{y} & \omega_{x} & 0
\end{array}
\right]
\end{equation}




* Progress                                                         :progress:
** README

1. 学习是有系统的
2. 长期零散化的知识吸收是有害的
3. 坚持就是力量
4. 要有优先级
5. 第一个学习任务对应一个项目，要有根目录
6. 每一个学习任务要有一个 ChangeLog 记录学习进度
7. 学习任务放在对应的笔记文件中，方便整理笔记，此处仅记录链接
8. 不打标签，仅在本文件链接上打标签
9. 每天抽出一个小时用于自我增值
10. 优先级为 A 的学习任务每周至少进行一次
11. 优先级为 B 的学习任务每两周一次
12. 拟名字要认真，不要轻易改，有链接

** 算法导论
*** 项目规化 [1/3]
- state "tobecontined" from "todo"       [2015-11-23 一 14:37]
- state "todo"       from ""           [2015-11-23 一 14:36]


1. [ ] 为什么要学习算法，我想过这个问题么？
2. [x] 教材选择： 《算法导论》
3. [ ] 整理已学习的内容
4. [ ] 学习计划

*** TODO Stression
**** Objective

+ [ ] 方阵的一般乘法算法的伪代码和Python实现
+ [ ] 方阵的一般分治
+ [ ] 方阵的Strassen乘法
+ [ ] 将以上算法推广到一般矩阵乘法

**** Notes

+ 优先使用 Python 实现算法，使用 C++ 容易过度关注语言本身的细节
+ 写的代码要有良好的歌读性，

**** 普通方阵乘法：Square-Matrix-Mutltiply(A, B)
***** 伪代码(preudo-code)

#+BEGIN_SRC latex
  \begin{algorithm}[H]
  SQUARE-MATRIX-MULTIPLY(A, B)\;
  n = A.rows\;
  let C be a new nxn matrix\;
  \For{i = 1 \KwTo n}{
    \For{j = 1 \KwTo n}{
      $C_{ij} = 0$
      \For{k = 1 \KwTo n}{
        $C_{ij} = C_{ij} + A_{ik}\cdot{B_{kj}}$
  }
  }
  }
  \Return C
  \end{algorithm}


#+END_SRC

***** Python实现
#+INCLUDE: ~/Wally/Journal/Project/Algorithm/SplitAndonquer/strassen.py :src python

** 数据结构

#+BEGIN_EXAMPLE
- state "tobecontined" from ""           [2015-11-23 一 14:39]
  算法与数据结构分不开
#+END_EXAMPLE


- 教材： [[~/Document/Algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90C%2B%2B%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%89%E7%89%88.pdf][数据结构与算法分析]]

*** 项目规化 [1/4]
- state "tobecontined" from ""           [2015-11-23 一 14:39]

1. [ ] 思考： 为什么学习数据结构？
2. [x] 教材选择： 《数据结构与算法分析：c++描述》
3. [ ] 整理已学习内容
4. [ ] 学习计划

*** 引论
**** 选择问题(selection problem)                     :selection:algorithm:

***** 问题描述

有一组n个数，要确定其第k个最大者
+ 输入： 数组a
+ 输出： 第k个最大数

***** 算法一

先排序，然后返回索引为k的元素

#+begin_src latex
  \begin{algorithm}[ht]
    sort-select(a, k)
    \kwdata{a: 数组， k: integer}
    sort(a)
    return a[k]
  \end{algorithm}
#+end_src

***** 算法二

先读入前k个元素并排序，接着将剩下的元素逐个读入，替换适当位置的元素或舍
弃。最终返回第k个元素

#+begin_src latex
  \begin{algorithm}[ht]
    optimized-sort-select
    \kwdata{a: array, k: index}
    \kwout{第k大元素}
    \blankline
    \begin{
      \for{i=1 \kwto k}{
        b[i] = a[i]
      }
      sort(b)
      \for{i=k+1 \kwto a.length}{
        j = k
        key = a[i]
        \while{key>b[j] and j>0}{
          b[j]=b[j-1]
          j = j-1
        }
        b[j-1] = key
      }
      return b[k]
    }
  \end{algorithm}
#+end_src

***** 实现

#+include: ~/Wally/Journal/Project/Algorithm/selects.h :src cpp

***** 算法的性能

length=1000万，k=5000,000时，两种算法都不能在合理的时间内完成（每种算
法都需要计算机处理若干天才能完成）
存在另外一种算法可以在1s左右给出答案。

**** c++类
***** 基本class语法

+ 学习类的程序风格
+ 文件以下划线连接的小写字母单词命名
+ 类使用驼峰式命名
+ 类的方法使用小写字母q命名
+ 合理的注释是必要的

#+begin_src latex
  \begin{cpp}
    /**
    ,* a class for simulating an integer memory cell
    ,*/

    class intcell
    {
      /**
      ,* construct the intcell
      ,* initial value is 0
      ,*/
      intcell(){
        storedvalue = 0;
      }

      /**
      ,* construct the intcell
      ,* initial value is initialvalue
      ,*/
      intcell(int initialvalue){
        storedvalue = initialvalue;
      }

      /**
      ,* return the stored value
      ,*/
      int read(){
        return storedvalue;
      }

      /**
      ,* change the stored value
      ,*/
      void write(int x){
        storedvalue = x;
      }

      private:
      int storedvalue;
    };

  \end{cpp}
#+end_src

***** 特别的构造函数和访问函数

#+begin_src latex
  \begin{cpp}
    /**
    ,* a class for simulating an integer memory cell.
    ,*/

    class intcelloptimized
    {
      public:
      explicit intcelloptimized(int initialvalue=0)
      : storedvalue(initialvalue) {}
      int read() const{
        return storedvalue;
      }
      void write(int x){
        storedvalue = x;
      }

      private:
      int storedvalue;

    };

  \end{cpp}
#+end_src


****** 四项优化
1. 使用默认参数（default parameter）

2. 初始化列表
   1) 在数据成员是具有复杂初始化过程的类类型时，使用初始化列表代替代码
      体中的赋值语句可以节省许多时间
   2) 如果一个数据成员是const（在对象被构造后就不能再改变），数据成员
      的值只能在初始化列表中时行初始化
   3) 如果一具数据成员是不具有零参数构造函数的类类型时，该数据成员的初
      始化也必须在初始化列表中进行

3. explicit构造函数
   1) 所有单参数的构造函数都必须是explicit的，以避免后台的类型转换；
   2) 否则一些宽松的规则将允许在没有显式类型转换操作的情况下进行类型转换
   3) 通常单构造函数定义了一个隐式类型转换(impllicit type conversion)，该转换创建一个临时对象，从而使赋值变得兼容
   4) intcell obj; obj = 37; // should not compile, 会转换为intcell temp = 37; obj = temp;

4. 常量成员函数
   1) 在c++中每个成员函数都被标记为访问函数(accessor)或者修改函数(mutator)
   2) 函数声明可以在不同的情况下以不同的方式使用const关键字，只有跟在结尾圆括号后面的const才标记一个访问函数

****** 其它优化
1. 预处理指令，防止多次包括同一文件 #ifndef intcell_h #define intcell_h #endif
2. 接口与实现分离
   1) 签名一致
   2) 默认参数仅在接口中被定义，在实现中被忽略

***** vector和string

c++标准定义了两个类vector和string。

*如果可能，应尽量避免使用c++内置数组和字符串。*

****** 内置数组带来的麻烦

内置数组的问题在于其行为与基本对象不同
+ 不能使用=复制
+ 不能记忆本身长度
+ 不能对索引进行边界检查

*** 表、栈和队列                                              :vector:list:

最基本的3种数据结构， *每一个有意义的程序都将明晰地至少使用一个这样的
数据结构*

**** 抽象数据类型

抽象数据类型(abstract date type, *ADT*)是带有一组操作的一些对象的集合。

抽象数据类型是数学的抽象：在ADT的定义中根本没有提到这组操作是如何实现
的。

e.g. 表、集合、图

**** 表ADT
***** 表ADT

表ADT： A_{0}, A_{1}, ..., A_{n-a}

表的大小(size)。

n=0, 空表(empty list)

A_{i} *后继* A_{i-1}; A_{i-1} *前驱* A_{i}

表的操作：
1. printList
2. makeEmpty
3. find
4. insert
5. remove
6. findKth

***** 表的简单数组实现

vector类

1. printList 线性时间
2. findKth 常数时间
3. insert/delete: O(N)
   1) 最坏的情况，在表头（位置0）插入删除元素，N
   2) 最好的情况，在表尾插入删除元素，O(1)
   3) 平均：线性时间

在许多情况，表是
1) 通过在 *末尾插入* 元素来 *建立* 的
2) 之后只有数组访问发生
这样，数组实现是适合和。

如果插入和删除都发生在表中的话，特别是前端的话，数组就不是一个好选择了。

***** 链表

为了避免插入和删除的线性开销 -> 表可以不连续存储。

[[~/Wally/Journal/Figure/scrot/59702FS.png]]

1. printList或find(x) 线性时间，但比数组要大

2. findKth(i) 以明显的遍历链表实现O(i)

   - 因此，调用findKth常常以排序（按i）方式进行

**** STL中的向量和表

Standard Template Library标准模板库。 集合(collection) 或 容器
(container)

表ADT的两种流行的实现

1. *vector*
   1) 优势： 在常量时间里是可索引的
   2) 缺点： 插入新项或者删除已有项的代价是高昂的，除非是在末端发生

2. *list* 双向链表
   1) 优点： 变化发生位置已知的话，插入新项和删除已有项的代价是很小的
   2) 缺点： 不容易索引

两者在查找时的效率都是很低的。

方法：

1. 公共的方法（所有STL）
   + int size() const
   + void clear()
   + bool empty

2. 常量时间内在末尾插入或者删除项
   + void push_back(const Object& x)
   + void pop_back()

3. 在常量时间内访问前端的项
   + const Object& back() const
   + const Object& front() const

4. 双向链表list特有的，对前端高效地改变
   + void push_front(const Object & x): 在list的前端加x
   + void pop_front(): 在list对象的前端删除对象

5. vector特有的方法
   + Object& operator[] (int idx)
   + Object& at(int idx)
   + int capacity() const
   + void reserve(int newCapacity): 设定新的容量

***** 迭代器

对于在表中插入删除的操作需要 *位置标记*,  -> 内置类型 *iterator* 给出
位置。

问题:
1) 如何得到迭代器
2) 迭代器可以执行什么操作（方法）
3) 哪些表ADT方法需要迭代器作为形参

****** 获得迭代器

+ iterator begin()
+ iterator end()  // 返回 *边界之外*

****** 迭代器方法

+ itr++ 和 ++itr
+ *itr
+ == 和 ！=

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
for(vector<int>::iterator itr = v.begin(); itr != v.end; ++itr){
}
\end{minted}
#+end_latex

或

#+begin_latex
\begin{minted}[frame=single, mathescape]{cpp}
vector<int>::iterator itr = v.begin()
while(itr != v.end()){
    cout << *itr++ << endl;
}
\end{minted}
#+end_latex

注：
- 后置自增运算符(++)优先级高于解引用(*)运算符，
- 后置自增运算符(++)表达式的返回值为原值，副作用是加1

****** 需要迭代器的容器操作

1. iterator insert(iterator pos, const Object& x)
   - 添加x到表中迭代器pos所指向的位置之前的位置
   - 对于list是常量时间，对于vector不是
   - 返回值是一个指向插入位置的迭代器

2. iterator erase(iterator pos)
   - 删除迭代器所给位置的对象
   - 对于list是常量时间，对于vector不是
   - 返回值是调用之前pos所指向元素的下一个元素的位置，这个操作使pos失
     效

3. iterator erase(iterator start,  iterator end)

表ADT的通用函数模板

[[~/Wally/Journal/Figure/scrot/5970DQY.png]]

****** const_iterator

1. iterator begin()
2. const_iterator begin() const
3. iterator end()
4. const_iterator end() const

方法的定常性(后置const修饰符)是标号(函数签名)的一部分。

**** 向量实现

***** Vector类需求分析

1. 数组的特性
   1) 数组就是指向一块内存的指针变量
   2) 内存块可以使用new[]来分配，相应地必须使用delete[]来释放
   3) 内在块的大小不能改变（但是可以定义一个新的具有更大内存块的数组，
      并且用原来的数组进行初始化）

2. Vector需求分析
   1) 存储基本数组和数组容量
   2) 三大函数
      - 复制构造函数和operator=深复制
      - 析构函数回收基本数组
   3) resize改变大小，reserve改变容量
      - 为新的数组分配一块新的内存块
      - 复制旧内存块到新的内存块
      - 释放旧的内存块
   4) operator[]
      - 访问函数
      - 修改函数
   5) size, empty, clear, back, pop_back, push_back(调用reserve增大容
      量)
   6) 支持嵌套的iterator和const_iterator类型，和begin和end方法

***** 实现

#+INCLUDE: ~/Wally/Journal/Project/DataStructure/Vector.h :src cpp


**** 栈
**** 队列

*** 树


**** Tree

***** 表 VS 树
对于大量数据， _线性表的访问时间太长_ ，不宜使用。

*树* 的大部分操作的平均运行时间为 /O(logN)/

/二叉查找树(binary search tree)/, 是 *set* 和 *map* 的实现基础。

应用：
- 文件系统
- 表达式树
- set/map

***** 基本概念

1. /树(tree)/: 由根结点以及零个或多个子树组成 （递归定义）
2. /根(root)/
3. /边(edge)/: 每个树由N个结点和N-1条边组成
4. /儿子(child)/
5. /父亲(parent)/
6. /叶结点(leaf)/
7. /兄弟结点(sibling)/
8. /祖父(grandparent)/
9. /孙子(grandchild)/
10. /祖先(ancestor)/
11. /后裔(descendant)/
12. /真祖先(proper ancestor)/
13. /真后裔(proper descendant)/
14. /路径(path)/: 从祖先到后裔的唯一路径
15. /长(length)/: 路径的条数
16. /深度(depth)/: 根到结点的长，根深度为0
17. /高度(height)/: 结点到叶子的最长路径的长，树叶的高度为0

***** 树的实现

将每个结点所有的儿子放在树结点的 *链表* 中。

#+BEGIN_SRC cpp
  /// \brief 一般树的实现
  ///
  /// 普通树直接存储所有子结点的链接会浪费许多空间
  struct TreeNode{
    Object element;
    TreeNode *firstChild;         ///< 指向儿子
    TreeNode *nextSibling;        ///< 指向兄弟
  }
#+END_SRC

***** 树的遍历

****** 前序遍历(preorder traversal)

/对结点的处理是在它的所有儿子结点处理之前进行的/

应用： 遍历目录



****** 后向遍历
** 德语学习

*** NEXT Trace
- State "NEXT"       from ""           [2016-01-12 二 21:42] \\
  - 整理了以前断断续续地学习笔记
  - 在虚拟机中安装了flash 播放软件

*** TODO 项目规化
1. [ ] 为什么要学习德语？
2. [ ] 什么时间和地点学习德语？
3. [ ] 学习一门语言需要平时投入零散的时间进行记忆，这一点我怎么做到？
4. [ ] 整理已经学习的内容并回顾？
5. [ ] 制定合理的学习计划

*** deutsch语音

**** Hello Deutsch

Guten Tag!

**** 德语概况

+ 德国国土面积相当于东北三省，人口8000万
+ 德国人的严谨来自德语的严谨
+ 德语入门难，动词的变位、名词的阴阳中性等
+ *德语是一门严谨、有规律的语言*
  - 发音的规律性，不需要标注音标，看字母组合即可发音
  - 德语语法复杂而严谨，不会出现歧义

**** 德语字母

**** 元音字母发音

|------+------+---------+--------------------------------------|
| 大写 | 小写 | 音标    | 发音                                 |
|------+------+---------+--------------------------------------|
| a    | a    | a       | 大圆口形，舌头平直，胸腔送气，长平音 |
| e    | e    | e       | 扁口形，舌头前低后高                 |
| i    | i    | i       | 闭齿间                               |
| o    | o    | o       | 与英语相似，小圆口形，腮部用力       |
| u    | u    | u       | 口噘起，小圆口形                     |
|------+------+---------+--------------------------------------|
| y    | y    | ypsilon | 半元音，处于辅音后面发元音yu         |
|      |      |         | 处于元音发辅音ye                            |
|------+------+---------+---------------------------------------------|

**** 变音

由两个元音字母组合而成的元音，有些时候写作两个元音形式

+ ä=ae ä=ae (\epsilon)  e的舌头位置，a的口形
+ ö=oe ö=oe (\phi)
+ ü=ue ü=ue (y:)

e.g.  müchen = muechen 慕尼黑

**** 长元音与短元音

元音后面出现两个或者两个以上辅音时发短音

1) 区别不大的元音：一个绵长，一个短促
   + a
   + i
   + u

2) 口形上的区别：e
   + 长： 扁口形 de
   + 短： 大口形 eff

3) 其它没有多少区别：变音

**** 辅音

|-------+-------+--------+------------------------------------------------------|
| r     | r     | err    | 发舌音，有小舌音（南德）和大舌音（北德，普通话）之分 |
|       |       |        | 舌头平放，喉部有振动                                 |
| v     | v     | fau    |                                                      |
| w     | w     | we     |                                                      |
| z     | z     | tsett  | ts一个辅音字母组合，发顶舌音，类似拼音中的c          |
| \beta | \beta | estett | 只有小写形式，没有大写形式，不会出现在词首 |
|       |       |        | 瑞士德语中写作ss，在单词中发轻音s                            |
|-------+-------+--------+--------------------------------------------------------------|

德语发音主要看字母组合，而不是单个字母

**** 元音字母组合

德语发音的一般规律
1) 第一音节一般为重读音节
2) 德语中没有连读，不要吃音

元音a发音规律
1) a单独出现在词尾时，一定发长音
2) a后面只有一个辅音时，也发长音
3) 以上规律适用于所有发长音的字母组合
4) 两个aa连续出现时，只发一个长音，该规律适用于oo和ee

|-----------+-------------+---------------------------------------|
| 音标      | 字母组合    | 例子                                  |
|-----------+-------------+---------------------------------------|
| a:        | a aa ah     | tag staat hahn                        |
| i:        | i ie ih     | china liebe ihnen                     |
| o:        | o oo oh     | oma boot lohn                         |
| u:        | u uh        | mut du schuh kuh                      |
| e:        | e ee eh     | wer see gehen                         |
| \epsilon: | ä äh        | baer laeden waehlen                   |
|           |             | baer狗熊，音同英语                    |
| \phi:     | ö öh        | oel boese soehne                      |
| y:        | ü üh y    | uebung fuehlen physik                 |
|-----------+-------------+---------------------------------------|
| 短元音    |             |                                       |
|-----------+-------------+---------------------------------------|
| a         | a           | ampel kalt blatt                      |
| o         | o           | komma oft gold                        |
| u         | u           | mutter jung muster                    |
| i         | i           | insel immer dick                      |
| e         | e           | name lage kommen                      |
|           |             | e在词尾的非重读音节中，短而轻         |
| y         | ue y        | huette system                         |
|           |             | 德语中出现y作为元音时，通常为外来词， |
|           |             | 拼写与英文相同，发音按德语发音规律    |
| \epsilon  | e ä         | hemd männer                           |
|           | ö           | löffel östlish köln                      |
|-----------+-------------+---------------------------------------|
| 复合元音  |             |                                       |
|-----------+-------------+---------------------------------------|
| ai        | ei ai ay ey | leitung mai bayern mayer              |
|           |             | ay ey 通常出现在人名和地名中          |
| au        | au          | haus laune blau                       |
| oi        | eu aeu      | leute heute baeume traeume            |
|-----------+-------------+---------------------------------------|

**** 辅音字母组合

清辅音和浊辅音

浊辅音b, d, g在词尾时发对应的轻辅音

|--------------+--------------------------------------------+----------------------------------------------------------------|
| 音标         | 字母组合                                   | 单词                                                           |
|--------------+--------------------------------------------+----------------------------------------------------------------|
| p            | p b                                        | papier lippe ab kalb                                           |
|              |                                            | 舌音处于词尾时不重读，一带而过                                 |
|              |                                            | 由两三个字母组成的小词中元音一般发短音                         |
| b            | b                                          | bild aber abend                                                |
|              | b在元音前面发浊音                          |                                                                |
|--------------+--------------------------------------------+----------------------------------------------------------------|
| t            | t tt th d dt                               | tafel bett thema wald                                          |
|              | th中h不发音，d，dt在词尾发清音             | 所有名词首字母大写                                             |
| d            | d dd                                       | dach nadel pudding                                             |
|--------------+--------------------------------------------+----------------------------------------------------------------|
| k            | k g ck c ch                                | kommaa tag ecke cola christ                                    |
| g            | g                                          | geld geben tage                                                |
|              |                                            | 德语单词如果以k c ch开关，并且发k的音，一般为外来词            |
|              |                                            | 但是存在例外，可能读作h，需要查字典，唯独c、ch开头的外来词如此 |
|--------------+--------------------------------------------+----------------------------------------------------------------|
| f            | f ff v ph                                  | familie schiff vater photo                                     |
| v            | w v                                        | wasser wo vase visum                                           |
| 上齿紧贴下唇 | v在德语单词中发f，在外来词中发v            |                                                                |
|--------------+--------------------------------------------+----------------------------------------------------------------|
|              | s在德语中发音特别复杂                      |                                                                |
| s            | s ss \beta                                 | skizze wissen hei \beta en                                     |
| z            | s                                          | sie sagen sind pause                                           |
|              | 1. s在辅音前及词尾发轻音s                  |                                                                |
|              | 2. ss \beta 永远发轻音 \beta前的元音发长音 |                                                                |
|              | 3. st sp组合在词头或重读音节中特殊         |                                                                |
|              | 4. s在元音前面发浊音                       |                                                                |
|--------------+--------------------------------------------+----------------------------------------------------------------|
| sh           | sch ch                                     | mensch schon chef chance                                       |
|              | ch在单词中有时发k                          |                                                                |
|              | ch在单词的开头并且发sh音时，为法语外来词   |                                                                |
| xi 舌头稍卷  | ch ig                                      | china ich wenig mutig                                          |
| x he         | ch                                         | bach doch buch auch                                            |
| 很重的送气音 | ch前面有元音a, o, u, au时，发x he          |                                                                |
|              | 除了上述四种情况，ch发其它音               |                                                                |
|--------------+--------------------------------------------+----------------------------------------------------------------|
| j            | j y                                        | juli ya yacht yard                                             |
| 卷舌         | y在外来词占发j音                           |                                                                |
| l            | l ll                                       | liebe laufen wollen voll                                       |
| r            | r rr                                       | franfurt rot schreiben                                         |
| m            | m mm                                       | dom machen kommen dumm                                         |
| n            | n nn                                       | name neu kennen wenn                                           |
| g            | ng                                         | angst lang                                                     |
|              |                                            | 元音在ng前面发短音                                             |
| h            | h                                          | halle himmel                                                   |
|              | h在元音后面不发音，th中h不发音             |                                                                |
|              | h在元音前面发h                             |                                                                |
|              | ch强烈送气，h比较轻                        |                                                                |
| ts 拼音c     | z c tz ts ds                               | zahn celsius sitzen                                            |
|              | z在德语中发ts                              | monatskrte abends                                              |
| ks           | chs ks x                                   | wachsen fuchs links text                                       |
|              | chs发清音不发浊音                          |                                                                |
|              | 德语中以大字母组合为主                     |                                                                |
| s            | s ss \beta                                 | skizze wissen heißen                                           |
| z            | s                                          | sie sagen sinal pause                                          |
| sh           | sch ch                                     | mensch schon chef chance                                       |
|              | ch在词中发sh音为法语外来词                 |                                                                |
| shp          | sp                                         | sport sprechen 浊音                                            |
|              | sp在词头或者重读音节中发sh                 |                                                               |
| sht          | st                                         | student stadt                                                  |
| kv           | qu                                         | qualität queue                                                 |
| pf 闭唇送气  | pf                                         | apfel pflanze                                                  |
| tsh ch       | tsch                                       | deutsch quatsch                                                |
|--------------+--------------------------------------------+----------------------------------------------------------------|


| xi                 | ch ig                     | china ich wenig mutig |
| s和sh之间轻微      | ig在词尾                  |                       |
| x(he 很重的送气音) | ch                        | bach doch buch auch   |
|                    | ch有元音字母a、o、u、au时 |                       |


xi

[[~/Wally/Journal/Figure/scrot/292818fO.png]]

ch 发音三个，查字典。

ch练习绕口令


from 3-3


[[~/Wally/Journal/Figure/scrot/29281j-g.png]]

from 3-4

| j(ri)     | j(yaot) y                             | juli ja yacht yard                              |
|           | y在外来词中发y, 在元音前              |                                                 |
| l         | l ll                                  | liebe laufen wollen voll                        |
| r 舌音he  | r rr                                  | frankfurt rot schreiben                         |
|           |                                       | r在元音的后面可以很轻，但在元音前面一定要发出来 |
| m         | m mm                                  | dom machen kommen dumm                          |
| n         | n nn                                  | name neu kennen wenn                            |
| g         | ng                                    | angst lang                                      |
| h         | h                                     | halle himmel                                    |
| ts(拼音c) | z c tz ts ds                          | zahn牙齿 celsius 摄氏度 sitzen坐                      |
|           | z只要出现在德语单词中发ts，不会发浊音 | monatskarte abends                              |
| ks        | chs(s永远发清音) ks x                  | wachsen(大组合为准) fuchs links text             |
| shp       | sp                                     | sport sprechen                                   |
|           | s在辅音前一般轻间，sp特殊sh，在词首    | 两个送气音，不好发，p发浊音，虽然标清音          |
| sht       | st 同上，在词首或重读音节中            | student stadt  d发浊音                              |


[[~/Wally/Journal/Figure/scrot/29281wIn.png]]

[[~/Wally/Journal/Figure/scrot/292819St.png]]

| kv         | qu           | qualität quelle |
|            | qu从来不分开 |                 |
| pf闭唇送气 | pf           | apfel pflanze   |
| tsh(拼音ch) | tsch         | deutsch quatsch |

**** 发音小结


1. 德语发音一般不标注音标，看到字母组合即可发音

   + ch, c, v开头需要查字典

2. 德语单词第一音节一般为重读音节

3. 元音发长音情形

4. 元音在双辅音或者两个以上辅音之前发短音

5. 元音字母e在词尾发轻音e

6. 浊辅音

   [[~/Wally/Journal/Figure/scrot/292818mC.png]]


7. s发音较多

   [[/home/wally/Wally/Journal/Figure/scrot/83440_Q.png]]

   [[/home/wally/Wally/Journal/Figure/scrot/8344BKX.png]]

8. v

   [[/home/wally/Wally/Journal/Figure/scrot/8344OUd.png]]

9. ch

   [[/home/wally/Wally/Journal/Figure/scrot/8344bej.png]]

   x 读作 (he)

10. y

    [[/home/wally/Wally/Journal/Figure/scrot/8344oop.png]]

11. 其它

    [[/home/wally/Wally/Journal/Figure/scrot/83441yv.png]]



04-3 7.58 车间练习处止

** 概率论

#+BEGIN_EXAMPLE
- state "todo"       from ""           [2015-11-23 一 15:01] \\
  概率论的知识十分重要
#+END_EXAMPLE

*** 项目计划 [/]
1. [ ] 教材选择
2. [ ] 学习计划
** 线性代数
#+BEGIN_EXAMPLE
- state "todo"       from ""           [2015-11-23 一 14:59] \\
  数学的知识是必不可少的，再难也不能放弃学习
#+END_EXAMPLE

*** 项目计划 [0/2]
- state "todo"       from ""           [2015-11-23 一 15:00]


1. [ ] 教材选择
2. [ ] 制定计划
** Raspberry 学习

#+BEGIN_EXAMPLE
- State "TODO"       from ""           [2015-11-23 一 15:07]
#+END_EXAMPLE

*** TODO 项目规化
- State "TODO"       from ""           [2015-11-23 一 15:07]

** Arduino 学习

#+BEGIN_EXAMPLE
- State "TOBECONTINED" from ""           [2015-11-23 一 14:57]
#+END_EXAMPLE

*** TODO 项目规化 [0/2]
1. [ ] 教材选择： 《Arduino Cookbook》
2. [ ] 整理已学习内容并制定新的计划

** ARM嵌入式系统开发
*** ARM基础
**** RISC设计思想

RISC是一种设计思想, 旨在设计出一套能在 *高时钟频率* 下 *单周期执行*, *
简单而有效* 的指令集, 设计重点在于降低硬件执行指令的复杂度.
+ 指令集: 单周期
+ 流水线: 并行
+ 寄存器: 通用
+ load-store结构: 外存访问

**** ARM设计思想
***** 客观需求
+ 低功耗
+ 高的代码密度
+ 存储器价格
+ 内核管芯面积(die)

***** 不同于RISC
+ 特定指令周期可变
+ 桶形移位器
+ Thumb 16位
+ 条件执行
+ 增强指令, eg, DSP支持
**** 嵌入式系统的硬件
***** ARM处理器
***** 控制器
+ 存储控制器
+ 中断控制器
  + 标准中断控制器
  +向量中断控制器(VIC): 优先级
***** 存储器
****** 层次
性能trade-off成本
+ cache
+ 主存
+ 辅助存储器

****** 宽度
8/16/32/64

****** 类型
+ ROM: 大宗
+ Flash ROM: 设备固件
+ DRAM: 需要设置控制器
+ SRAM: 高速存储器和cache
+ SDRAM: 同步动态随机访问存储器
***** 外设
*所有的ARM外设都是存储器映射---编程接口是一组对应于某些存储器地址的寄
存器. 这些寄存器的地址是某个特定外设的基地址的偏移量*

***** 总线
1. VS x86
   + x86 PC: PCI, 片间总线
   + ARM: 片上总线
2. 总结层次
   + 物理层: 电气特征, 宽度
   + 协议层(ARM)
3. AMBA(高级微控总线结构)
   + ASB(ARM系统总线)
   + APB(ARM外设总线)
   + AHB(ARM商性能总线)
**** 嵌入式系统的软件
***** 初始化(启动)代码
启动代码使处理器从复位状态进入到操作系统能够运行的状态.
+ 初始化配置
+ 诊断
+ 引导
***** 设备驱动
***** 操作系统
+ 实时操作系统(RTOS)
+ 平台操作系统: Linux
***** 应用程序
** Linux内核设计与实现
*** Kernel:整理1,2
**** Linux内核简介
***** 单内核 VS 微内核
****** 单内核
所谓单内核,就是把内核从整体上作为一个单独的大过程实现,同时也运行在一个
单独的地址空间上.
+ 内核通常以单个静态二进制文件的形式存放在磁盘中.
+ 内核之间的通信微不足道
+ 简单,性能高,多数Unix系统都设计为单模块
****** 微内核
微内核的功能被划分为多个独立的过程,每个过程叫作一个服务器.所有的服务器
都运行在各自的空间上.
+ 通过消息传递处理微内核通信: 采用进程间通信(IPC)机制
+ 服务器独立有效地避免了一个服务器失效祸及另一个
+ IPC机制的开销多于函数调用
+ OS X, Windows NT(XP, Vista, 7)等

****** Linux是一个单内核,但汲取了微内核的精华
+ 模块化设计
+ 抢占式内核
+ 支持内核线程
+ 动态装载内核模块

Linux还避免了微内核设计上性能缺失的缺陷,让所有的事情都运行在内核上,直
斥调用函数,无须消息传递.

Linux是模块化的,多线程的以及内核本身可调度的操作系统.

***** Linux与传统Unix的区别
+ Linux支持动态加载内核模块
+ Linux支持对称多处理(SMP)机制
+ Linux内核可抢占(preemptive)
+ Linux不区分线程和一般进程
+ Linux提供具有设备类的面向对象的设计模型,热插拔事件,以及用户空间的设
  备文件系统(sysfs)
+ Linux忽略了一些被认为设计很拙劣的Unix特性和一些过时标准
+ Linux体现了自由的精髓.

不管Linux和Unix有多大不同,它身上都深深打上了Unix烙印.

***** Linux版本号
Linux内核有两种:
+ 稳定的(具有工业级强度)
+ 开发中的(变化剧烈)

Linux使用简单的命名机制来区分稳定的和处于开发中的版本.Linux版本号使用
三个或四个用句点分开的数字来表示不同的版本.
+ 主版本号
+ 从版本号(偶数表示稳定版,奇数表示开发版)
+ 修订版本号
+ 稳定版本号(可选)
  [[~/Tiger/journal/figures/48846MU.png]]

***** Linux内核开发者社区
社区最重要的论坛是Linux Kernel Mailing List(lkml),可以在
http://vegr.kernel.org 上订阅邮件.

**** 从内核出发

***** 获取内核源码
Linux内核官方网站: http://www.kernel.org
使用git
***** 内核源码树
 |---------------+--------------------|
 | arch          | 特定体系结构的源码 |
 | block         | 块设备I/O层        |
 | crypto        | 加密API            |
 | Documentation | 内核源码文档       |
 | drivers       | 设备驱动程序       |
 | firmware      | 使用某些驱动程序而需要的设备固件 |
 | fs            | VFS系统和各种文件系统            |
 | include       | 内核头文件                       |
 | init          | 内核引导和初始化                 |
 | ipc           | 进程间通信代码                   |
 | kernel        | 像调度程序这样的核心子系统       |
 | lib           | 通用内核函数                     |
 | mm            | 内核管理系统和VM                 |
 | net           | 网络子系统                       |
 | samples       | 示例,示范代码                    |
 | scripts       | 编译内核所用的脚本               |
 | security      | Linux安全模块                    |
 | sound         | 语音子系统                       |
 | usr           | 早期用户空间代码                 |
 | tools         | 在Linux开发中有用的工具          |
 | virt          | 虚拟化基础结构                          |
 |---------------+-----------------------------------------|

***** 编译内核
编译时间很长...
****** 配置内核
编译前需要先进行配置.Linux开源,编译Linux内核可以配置和定制.配置选项以
CONFIG_FEATURES形式表示,前缀为CONFIG.配置选项要么是二选一,要么是三选一.

像Canonical的Ubuntu或者Red Hat的Fedora的发布版中包含了预编译的内核.内
核黑客应当编译自己的内核,并按自己的竟意愿决定包含或不包含哪一个模块.

******* $ make config
字符界面下的命令行工具,逐一遍历所有配置项.
******* 图形界面工具
+ $ make menuconfig    # 基于ncurse库
+ $ make gconfig       # 基于gtk+
******* 默认配置
$ make defconfig    # 缺省值,良好开端

******* 配置文件
内核代码树根目录下 *.config* 文件.
$ make oldconfig    # 验证和更新所修改的配置
配置选项CONFIG_IKCONFIG_PROC把完整的压缩过的内核配置文件存放在
/proc/config.gz下,可克隆到当前配置.
****** 编译内核
******* 减少编译的垃圾信息
******* 衍生多个编译作业

***** 内核开发
内核开发与应用程序开发的区别
****** 内核编程既不能访问C库,也不能访问标准的C头文件
+ 内核不能链接使用标准C函数.
+ 大部分常用的C库函数在内核中都已经得到了实现.
+ 内核开发的头文件指的是内核源码树的内核头文件
  - 基本头文件位于顶级目录下的include文件夹中
  - 体系相关的头文件位于arch/<architecture>/include/asm目录下.内核代码
    通过以asm/前缀前缀的方式包含这些头文件.
****** 内核编程必须使用GNU C
Linux使用C写成,但内核不完全符合ANSI C标准,内核开发者总是用到gcc提供的
许多语言的扩展部分.
******* 内联函数
C99和GNU C均支持内联函数[fn:1502270116].
******* 内联汇编
gcc编译器支持在C语言中嵌入汇编指令.经常使用asm()指令嵌入汇编代码.
******* 分支声明
gcc内建一条指令用于优化条件选择语句,内核将其封装成宏likely()等.

****** 内核编程缺乏内存保护机制
****** 内核编程难以执行浮点运算
****** 内核给每个进程只有一个很小的定长堆栈
****** 内核支持异步中断,抢占和SMP,因此必须注意同步和并发
****** 要考虑可移植性的重要性
** OpenCV 学习

*** 项目规化 [1/2]

1. [X] why: 以后必然离不开计算机视觉
2. [ ] 整理资源与选择教材(*最好是书籍教材*)
3. [ ] 项目计划

** 数字图像处理

#+BEGIN_EXAMPLE
- State "TODO"       from ""           [2015-11-23 一 14:43] \\
  应该很好玩
#+END_EXAMPLE

*** 项目规化
1. [ ] 思考： 为什么要学习数字图像处理？
2. [ ] 教材选择：数字图像处理， matlab版还是一般版本(使用Python实现)，
   现在等倾向于后者
3. [ ] 学习计划

** GNU Make

#+BEGIN_EXAMPLE
- State "TOBECONTINED" from "TODO"       [2015-11-23 一 14:34]
- State "TODO"       from ""           [2015-11-23 一 14:12] \\
  Make学习之路
#+END_EXAMPLE

*** 项目规化
1. 学习教材： 《GNU Make项目管理》
2. 学习计划： *按章节来* ，教材布局合理，由浅入深，内容均布
   1) 首先无笔记式地阅读书籍，计划平均 *1小时*
      - 不圈不点
      - 不实现程序
      - 遇到不会但不是核心的东西暂时不管
   2) 阅读电子版书籍，计划平均 *1.5小时*
      - 实现源码
      - 做ORG-笔记
      - 将不会但不相关的知识使用 *org-capture* 添加到待为事项中，等有
        时间处理
   3) *小结* 并 规化下一步

*** make 入门
- State "TOBECONTINED" from ""           [2015-11-23 一 17:25]
CLOCK: [2015-11-20 五 18:31]--[2015-11-20 五 19:43] =>  1:12
CLOCK: [2015-11-20 五 10:12]--[2015-11-20 五 11:24] =>  1:12

**** minted for makefile                                          :minted:
#+begin_example
  $ pygmentize -l lexers | grep make
  ,* basemake:
  ,* cmake:
      cmake (filenames *.cmake, cmakelists.txt)
  ,* make, makefile, mf, bsdmake:
      makefile (filenames *.mak, makefile, makefile, makefile.*, gnumakefile)
#+end_example

*make,  makefile,  mf*

**** make VS scripts
相对于脚本，make的优点是：
*你可以把程序中各元素之间的关系告诉make，然后make会根据这些关系和时间
戳判断应该重新进行哪些步骤，以及产生你所需要的程序*

**** 规则(rule)
1) 工作目标(target)
2) 必要条件(prerequisite)
3) 命令(command)

#+begin_latex
  \begin{minted}[frame=single, mathescape]{mf}
  target:prereq1 prereq2
      commands
  \end{minted}
#+end_latex

e.g.
#+begin_latex
\begin{minted}[frame=single, mathescape]{mf}
foo.o: foo.c foo.h
    gcc -c foo.c
\end{minted}
#+end_latex

运行过程中任何错误都会使make终止工作目标的建立并结束运行。

demo1

** 数据库学习

#+BEGIN_EXAMPLE
- State "TODO"       from ""           [2015-11-23 一 14:48] \\
  数据库的学习可能有必要
#+END_EXAMPLE

*** TODO 项目规化 [1/1]

1. [X] 数据库选择: MySQL 还是 SQLite（优点之一，无后台服务，可以应用于嵌入
   式中）
2. [ ]必要性在哪： *没有找到切切实实的应用之前不要开始*
** Qt 学习
*** 项目规化
*** Chapter 1
**** Hello Qt
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("Hello Qt!");
    label->show();
    return app.exec();
  }
#+END_SRC

+ 窗口部件(widget)是指用户界面的一个可视化元素，该词源于"window
  gadget"（窗口配件），相当于Window系统术语的”控件”(control)和”容
  器”(container).
+ QApplication对象用于管理整个应用程序所用到的资源，以argc和argv为参
  数，也就是说，Qt支持自己的一些命令行参数。
+ 绝大多数应用程序都会使用一个QMainWindow或一个QDialog作为它的窗口，但
  Qt是如此灵活，以至于任意窗口部件都可以用作窗口。
+ show()方法使部件可见，在创建窗口部件时标签通常都是隐藏的，这样允许先
  进行设置再显示，避免闪烁。
+ app.exec()方法使程序进入事件循环状态，这是一种等待状态，程序会等候用
  户的动作。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/helloqt2/helloqt.cpp
  #include <QApplication>
  #include <QLabel>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QLabel* label = new QLabel("<h2><i>Hello</i><font color=red>Qt!</font></h2>");

    label->show();
    return app.exec();
  }
#+END_SRC

+ 通过使用一些简单的HTML样式格式，就可以轻松地把Qt应用程序的用户接口变
  得丰富多彩。
**** 建立连接
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/quit/quit.cpp
  #include <QApplication>
  #include <QPushButton>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QPushButton *button = new QPushButton("quit");
    QObject::connect(button, SIGNAL(clicked()), &app, SLOT(quit()));
    button->show();
    return app.exec();
  }

#+END_SRC

**** 窗口部件的布局
#+BEGIN_SRC cpp :exports code :tangle /home/ben/Project/C++/Qt/Qt4/chapter01/age/age.cpp
  #include <QApplication>
  #include <QHBoxLayout>
  #include <QSpinBox>
  #include <QSlider>

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    QWidget* window = new QWidget;
    window->setWindowTitle("Enter your age:");

    QSpinBox* spinBox = new QSpinBox;
    QSlider* slider = new QSlider(Qt::Horizontal);
    spinBox->setRange(0, 130);
    slider->setRange(0, 130);

    QObject::connect(spinBox, SIGNAL(valueChanged(int)),
                     slider, SLOT(setValue(int)));
    QObject::connect(slider, SIGNAL(valueChanged(int)),
                     spinBox, SLOT(setValue(int)));

    QHBoxLayout* layout = new QHBoxLayout;
    layout->addWidget(spinBox);
    layout->addWidget(slider);
    window->setLayout(layout);
    window->show();
    return app.exec();
  }
#+END_SRC

Qt有三个主要的布局管理器：
+ QHBoxLayout
+ QVBoxLayout
+ QGridLayout

**** 窗口部件的风格
Qt应用程序在每个平台上都可以看起来像本地程序一样，Qt是通过所模拟平台的
外观来实现这一点的，而不是针对某个特殊平台的封闭或者一个工具包中的窗口
部件集。
+ Plastique(KDE)
+ Cleanlooks(GNOME)
+ CDE
+ motif
+ Windows(仅能在本地平台上有效，因为需要依赖平台的主题引擎，下同)
+ Windows XP
+ Windows Vista
+ Mac


在X11下，可以在命令行设置程序窗口风格
#+BEGIN_EXAMPLE
./out -style motif
#+END_EXAMPLE

*** 创建对话框
**** 子类化QDialog
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.h
  #ifndef FINDDIALOG_H
  #define FINDDIALOG_H

  #include <QDialog>

  class QCheckBox;
  class QLabel;
  class QLineEdit;
  class QPushButton;

  class FindDialog : public QDialog{
    Q_OBJECT

  public:
    FindDialog(QWidget *parent=0);

  signals:
    void findNext(const QString& str, Qt::CaseSensitivity cs);
    void findPrevious(const QString& str, Qt::CaseSensitivity cs);

  private slots:
    void findClicked();
    void enableFindButton(const QString& text);

  private:
    QLabel *label;
    QLineEdit *lineEdit;
    QCheckBox *caseCheckBox;
    QCheckBox *backwardCheckBox;
    QPushButton *findButton;
    QPushButton *closeButton;
  };

  #endif
#+END_SRC

+ 前置声明(forward declaration)告诉C++编译器类的存在，而不用提供类定义
  的所有细节
+ 前置声明的类型在头文件中使用指针声明
+ 编译速度快
+ FindDialog(QWidget *parent=0)为典型的Qt窗口部件构造函数定义方式，
  parent参数指定部件的父窗口，默认为空指针，即没有父对象。
+ 对于所有使用信号和槽的类，在类定义开始处的 Q_OBJECT 宏是必须的。
+ signals部分定义信号，signals实际上是一个宏，C++预处理器会在编译程序
  前将其转换为标准C++代码
+ Qt::CaseSensitivity是枚举类型
  - Qt::CaseSensitive
  - Qt::CaseInsensitive
+ slots部分定义槽，也是宏

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/finddialog.cpp
  #include <QtWidgets>
  #include "finddialog.h"

  FindDialog::FindDialog(QWidget *parent)
    : QDialog(parent)
  {
    label = new QLabel("Find &What:");
    lineEdit = new QLineEdit;
    label->setBuddy(lineEdit);

    caseCheckBox = new QCheckBox("Match &case");
    backwardCheckBox = new QCheckBox("Search &backward");

    findButton = new QPushButton("&Find");
    findButton->setDefault(true);
    findButton->setEnabled(false);

    closeButton = new QPushButton("&Close");

    connect(lineEdit, SIGNAL(textChanged(const QString&)),
            this, SLOT(enableFindButton(const QString&)));
    connect(findButton, SIGNAL(clicked()),
            this, SLOT(findClicked()));
    connect(closeButton, SIGNAL(clicked()),
            this, SLOT(close()));

    QHBoxLayout *topLeftLayout = new QHBoxLayout;
    topLeftLayout->addWidget(label);
    topLeftLayout->addWidget(lineEdit);

    QVBoxLayout *leftLayout = new QVBoxLayout;
    leftLayout->addLayout(topLeftLayout);
    leftLayout->addWidget(caseCheckBox);
    leftLayout->addWidget(backwardCheckBox);

    QVBoxLayout *rightLayout = new QVBoxLayout;
    rightLayout->addWidget(findButton);
    rightLayout->addWidget(closeButton);
    rightLayout->addStretch();

    QHBoxLayout *mainLayout = new QHBoxLayout;
    mainLayout->addLayout(leftLayout);
    mainLayout->addLayout(rightLayout);
    setLayout(mainLayout);

    setWindowTitle("Find");
    setFixedHeight(sizeHint().height());
  }


  void FindDialog::findClicked(){
    QString text = lineEdit->text();
    Qt::CaseSensitivity cs =
      caseCheckBox->isChecked() ? Qt::CaseSensitive
      : Qt::CaseInsensitive;
    if(backwardCheckBox->isChecked()){
      emit findPrevious(text, cs);
    }else{
      emit findNext(text, cs);
    }
  }

  void FindDialog::enableFindButton(const QString &text){
    findButton->setEnabled(!text.isEmpty());
  }

#+END_SRC
+ #include <QtWidgets>包含所有窗口部件，但在一个头文件中包含一个在的头文
  件着实不是一个好的编程习惯。
  + Qt4 $include <QtGui>
+ 构造函数中把parent参数传递给基类的构造函数
+ tr()函数表示翻译，有时是不错的选择
+ &操作符表快捷键(Alt+W)
+ 所谓“伙伴”(buddy)，就是一个窗口部件，它可以在按下标签的快捷键时接
  收焦点(focus).
+ setDefault()设定默认按钮(default button), 即当用户按下Enter键时对应
  的按钮。
+ 通过 QHBoxLaytout,QVBoxLayout,QGridLayout的不同嵌套组合，可以构建出
  相当复杂的对话框。
+ addStrentch方法增加分隔符(伸展器)，用来占据空白区域
+ 当将子布局对象添加到父布局对象，子布局对象就会重新定义自己的父对象。
  它所有的子窗口部件都会重新定义自己的父对象。
+ QWidget::sizeHint()方法返回部件“理想”的尺寸大小
+ 创建窗口对象使用的是new，所以需要调用delete来析构。但这样不是必须的，
  Qt在删除对象时会自动删除所有的子对象
+ emit是Qt扩展的关键字，像其它Qt扩展一样，它也会被C++预处理器转换为标
  准的C++代码

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "finddialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    FindDialog *dialog = new FindDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 为了使 *moc* 能够正常运行，必须把类定义从实现文件中分离出来并放到头
  文件中
+ 必须对使用了Q_OBJECT宏的类运行moc(qmake),否则会出现不明确的错误信息。
+ 默认的Tab键顺序是创建窗口部件的顺序，可以使用QWidget::setTabOrder()
  方法设置
+ 提供一种合理的Tab键顺序的键盘快捷键可以确保不愿（或者不能）使用鼠标
  的用户能够充分享受应用程序提供的全部功能。完全通过键盘控制应用程序也
  深受快速输入人员的赞赏。

**** 信号和槽
1. 槽
   + 可以是虚函数
   + 可以被重载
   + 可以是公有的，私有的，保护的
   + 可以被其它成员函数直接调用
   + 参数可以是任意类型
   + *槽可以与信号连接*
2. connect(sender, SIGNAL(signal), receiver, SLOT(slot))
   + sender, receiver是指向QObject的指针
   + signal和slot是不带参数的函数名
3. 机制
   + 一个信号可以连接多个槽
     + 发射信号时，会以不确定的顺序一个接一个调用关联的槽
   + 多个信号可以关联一个槽
   + 一个信号可以与另外一个信号关联
     #+BEGIN_EXAMPLE
       connect(lineEdit, SIGNAL(textChanged(const QString&))
               this, SIGNAL(updateRecord(const QString&)))
     #+END_EXAMPLE
   + 连接可以被移除
     + 很少用，当删除对象时，Qt会自动移除和这个对象相关的所有关联。
4. 注意
   + 信号和槽的参数必有有相同的顺序和相同的类型
   + 信号的参数比槽多时，多余参数会为被忽略
   + 不匹配则警告
   + 信号和槽机制是由QObject实现，并不只是局限于图形界面编程

**** Qt的对象系统
moc(meta-object system), 对C++的重要扩展。
+ 信号和槽
+ 内省
**** 快速设计对话框
Qt的设计初衷是为了能够直观并且友好也进行 *手工编码* ，并且对于程序员来
说， 编写C++源代码开发整个Qt应用程序并不稀奇。

QtDesigner提供了Qt的可视化编码方式。

手工编码和使用QtDesigner在创建对话框时的基本步骤是一致的
1. 创建并初始化子窗口部件
2. 把子窗口部件放到布局中
3. 设置Tab键顺序
4. 建立信号的槽的连接
5. 实现对话框自定义的槽

***** 使用QtDesigner设计对话框并保存为 ui 文件
+ filename.ui
+ Qt用户界面编译器(user interface compiler, uic) 将ui文件转换为C++代码
  + $ uic filename.ui
  + ui_filename.h
    + 头文件中包含了Ui::GoToCellDialog的定义(GoTocelldialog为
      QtDesigner设计的窗体的顶层部件的objectName)
    + setupUi()函数用于初始化窗体

****** 直接使用
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>
  #include <QDialog>

  #include "ui_gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);

    Ui::GoToCellDialog ui;
    QDialog *dialog = new Dialog;
    ui.setupUi(dialog);
    dialog.show();
    return app.exec();
  }

#+END_SRC

+ 什么也做不了

****** 多继承：最简捷
#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.h
  #ifndef GOTOCELLDIALOG_H
  #define GOTOCELLDIALOG_H

  #include <QDialog>

  #include "ui_gotocelldialog.h"

  class GoToCellDialog : public QDialog, public Ui::GoToCellDialog{
    Q_OBJECT

  public:
    GoToCellDialog(QWidget *parent=0);

  private slots:
    void on_lineEdit_textChanged();
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/gotocelldialog.cpp
  #include <QtWidgets>

  #include "gotocelldialog.h"

  GoToCellDialog::GoToCellDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");
    lineEdit->setValidator(new QRegExpValidator(regExp, this));

    connect(okButton, SIGNAL(clicked()), this, SLOT(accept()));
    connect(cancelButton, SIGNAL(clicked()), this, SLOT(reject()));
  }

  void GoToCellDialog::on_lineEdit_textChanged(){
    okButton->setEnabled(lineEdit->hasAcceptableInput());
  }
#+END_SRC

+ setUp()还会自动将那些符合on_objectName_signalName()命名惯例的任意槽
  与相应的objectName的signalName()信号连接到一起。
+ Qt提供了三种内置检验器类:
  - QIntValidator
  - QDoubleValidator
  - QRegExpValidator
+ 通过this传递绘QRegExpValidator的构造函数，使它成为窗口的子对象，这样
  就可以不用担心有关删除QRegExpValidator的事情了，当删除它的父对象时，
  会被自动删除。
+ Qt的父子对象机制是在QObject中实现的。很大程度上简化了内在管理的工作，
  降低了内在泄漏的风险。需要明确删除的是那些使用new创建并且没有父对象
  的对象。
+ accept()和reject()槽都可以关闭对话框，前者将QDialog::Accepted置1,后
  者置0.

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/main.cpp
  #include <QApplication>

  #include "gotocelldialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    GoToCellDialog *dialog = new GoToCellDialog;
    dialog->show();
    return app.exec();
  }

#+END_SRC

+ 注：org tangle不会覆盖已存在的文件

**** 改变对话框的形状
+ 扩展对话框(extension dialog)
+ 多页对话框(multi-page dialog)

***** 扩展对话框

Qt Designer允许我们在构成同一窗体的不同部分内的窗口部件之间建立连接。
+ Edit -> Edit Signals/Slots 进入设置连接模式。

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.h
  #ifndef SORTDIALOG_H
  #define SORTDIALOG_H

  #include <QDialog>

  #include "ui_sortdialog.h"

  class SortDialog : public QDialog, public Ui::SortDialog{
    Q_OBJECT

  public:
    SortDialog(QWidget *parent=0);
    void setColumnRange(QChar first, QChar last);
  };

  #endif
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/tmp/sortdialog.cpp
  #include <QtWidgets>

  #include "sortdialog.h"

  SortDialog::SortDialog(QWidget *parent)
    : QDialog(parent)
  {
    setupUi(this);

    secondaryGroupBox->hide();
    tertiaryGroupBox->hide();
    layout()->setSizeConstraint(QLayout::SetFixedSize);

    setColumnRange('A', 'Z');
  }

  void SortDialog::setColumnRange(QChar first, QChar last){
    primaryColumnCombo->clear();
    secondaryColumnCombo->clear();
    tertiaryColumnCombo->clear();

    secondaryColumnCombo->addItem("None");
    tertiaryColumnCombo->addItem("None");
    primaryColumnCombo->setMinimumSize(
                                       secondaryColumnCombo->sizeHint());

    QChar ch = first;
    while(ch <= last){
      primaryColumnCombo->addItem(QString(ch));
      secondaryColumnCombo->addItem(QString(ch));
      tertiaryColumnCombo->addItem(QString(ch));
      ch = ch.unicode()+1;
    }
  }
#+END_SRC

#+BEGIN_SRC cpp :exports code :tangle /home/ben/main.cpp
  #include <QApplication>

  #include "sortdialog.h"

  int main(int argc, char *argv[])
  {
    QApplication app(argc, argv);
    SortDialog *dialog = new SortDialog;
    dialog->setColumnRange('C', 'F');
    dialog->show();
    return app.exec();
  }

#+END_SRC

***** 多页对话框
+ QTabWidget
+ QListWidget
+ QStackedWidget


**** 动态对话框
+ 动态对话框(dynamic dialog)就是在程序运行时使用的从Qt设计师的.ui文件
  创建而来的那些对话框。
+ 运行时加载，而非先使用uic将ui文件转换为C++代码
+ 使用QUiLoader类载入ui文件
  #+BEGIN_EXAMPLE
    QUiLoader uiLoader;
    QFile file("sortdialog.ui");
    QWidget *sortDialog = uiLoader.load(&file);
    if(sortDialog){
        ...
    }
  #+END_EXAMPLE
+ 使用QObject::findChild<T>()来访问窗体中的各个子窗口部件
  #+BEGIN_EXAMPLE
    QComboBox *primaryColumnCombo =
              sortDialog->findChild<QCombobox *>("primaryColumnCombo");
    if(primaryColumncombo){
        ...
    }
  #+END_EXAMPLE
+ 对于MSVC 6, 须使用全局函数qFindChild()函数代替
+ QUiLoader类放在一个独立的类库中，需要在pro文件中加入 CONFIG += uitools

**** 内置的窗口部件和对话框
1. 按钮
   + QPushButton
   + QToolButton
   + QRadioButton
   + QCheckButton
2. 容器
   + QGroupBox
   + QFrame
3. 多页窗口部件
   + QTabWidget
   + QToobBox
4. 项视图窗口部件
   + QListView(列表/图标)
   + QTreeView
   + QTabView
5. 显示窗口部件
   + QLabel(应用最多，显示普通文本，HTML，图片)
   + QLCDNumber
   + QProgressBar
   + QTextBrowser
6. 输入窗口部件
   + QLineEdit
   + QTextEdit
   + QSpinBox
   + QDoubleSpinBox
   + QComboBox
   + QDateEdit
   + QTimerEdit
   + QDateTimeEdit
   + QScrollBar
   + QSlider
   + QDial
7. 对话框
   + QInputDialog
   + QProgressDialog
   + QMessageBox
   + QErrorMessage
   + QColorDialog
   + QFontDialog
   + QPageSetupDialog
   + QFileDialog
   + QPrintDialog
8. 向导
   + QWizard
9. 富文本引擎
   Qt库含有一个富文本引擎(rich text engine)，用于格式化文本的显示和编
   辑。
